  > **Database Internals 2장. B-트리 개요**를 읽고, 해당 장에 대해 정리하기에 앞서 자료구조라는 것에 대해 짚고 넘어가야겠다고 생각이 들었다. 
  '노드'라는 것이 계속 쓰이는데 도대체 이 '노드'가 실제로 물리적으로 무엇을 의미하는 것인지,
  이 자료구조라는건 어디서 누가 무엇을 위해 필요한건지,
  주소값이라는 것은 또 논리적으로 물리적으로 무엇을 가리키는건지 이참에 꼭 정리하고자 했다.
  
  우선 현재 머리에 얹혀져있는것만이라도 날아가기 전에 후다닥 나열해놓고 추후 수정하겠다.
  
  B+Tree 구조 기준으로 정리한다.
  
  # 자료구조의 정의
  - 컴퓨터과학에서 데이터를 구조적으로 표현하는 방식과 이를 구현하는 데 필요한 알고리즘에 대해 논하는 기초이론, 혹은 과목. (출처. 나무위키)
  - 컴퓨터의 메모리는 1차원 구조이기 때문에 현실 세계의 다차원 데이터를 다루기 위해서는 이것을 1차원인 선 형태로 바꾸는 것이 필요하다.
  
  # 트리(Tree)
  ## 용어
  - 세 종류의 노드
    - 루트 노드(root node): 부모가 없는 노드, 트리는 하나의 루트 노드를 갖는다.
    - 리프 노드(leaf node): 자식이 없는 말단 노드. 
    - 내부 노드(internal node): 루트노드, 리프노드 외의 노드.
  - 팬아웃(fan out): 가질 수 있는 최대 자식 노드 개수 
  
  # 이진 탐색 트리 (BST, binary search tree)
  - 각 노드는 최대 두개의 자식 노드를 갖는다.
  - 노드의 왼쪽 서브트리에는 그 노드의 값보다 작은 값들을 지닌 노드들로 이루어져 있다.
  - 노드의 오른쪽 서브트리에는 그 노드의 값보다 큰 값들을 지닌 노드들로 이루어져 있다.
  
  ## BST한계
  ### - 불균형 문제
  - 정렬된 데이터를 순차적으로 삽입하면 한쪽으로 치우친 트리가 생성된다.
  - 트리가 불균형해질 경우 검색 시간이 증가하며, 탐색 시간 복잡도는 **O(n)**으로 선형 탐색과 동일해진다.
  
  ### - 노드 활용 비효율성
  - 팬아웃이 작은 BST는 데이터가 증가할수록 트리의 깊이가 증가한다. 이는 시간 복잡도 측면에서 효율성을 저하시킨다.
  - 디스크 블록 당 데이터 활용 효율이 낮아(노드 하나에 한개의 키와 두개의 자식) 디스크 I/O 작업이 증가한다.
  
  # B-트리(B-Tree)
  - 이진 트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조이다. (= **트리 높이가 낮다**)
  - 디스크(또는 SSD) 기반 저장소에 최적화된 균형 탐색 트리 (디스크 접근 횟수 최소화)
  - 노드는 n개의 키(key)와 n+1개의 자식(포인터)을 갖고있다.
  
  # B+트리(B+Tree)
  - B-트리와 대조적으로, 모든 레코드들은 **리프 노드**에만 존재하며 **내부 노드**에는 **키(key)**만이 저장된다.
  
  ## B+트리 이해하기
  ### - 논리 개념 : 물리 개념 매핑
  |논리 개념|물리 개념|
  |:---|:---|
  |B+Tree 노드|디스크 페이지(Page)|
  |노드 포인터|page_id|
  |트리 이동|page_id -> page_id|
  
  ### - 키(key)
  - 실제 데이터가 아니다.
  - 탐색 경로를 나누는 기준(경계값)이다.
  - 우리(개발자)가 테이블을 생성할 때의 index가 이 key에 해당한다고 볼 수 있다. 즉, 정렬할 수 있는 대부분의 자료 타입이 key가 될 수 있다.(int, bigint, char, varchar, date, datetime 등)
  
  ---
  
  - 페이지란 디스크 내에서 읽고 쓸 수 있는 가장 작은 물리 단위이며 고유 정수값인 id를 갖고 있다.
  - 자료구조에서 정렬/탐색 시에 사용되는 그 '노드 번호'라는게 'page_id'라고 보면 된다.
  
  - 우리(개발자)가 테이블을 생성하면 일반적으로 기본 인덱스인 PK가 있고, 추가적으로 secondary index를 생성할 수 있다.
    - 생성한 테이블의 각각의 index에 대해 B+Tree가 존재하게 된다.
    - 실제 데이터는 PK B+Tree의 리프노드에 저장돼있다.
    - 다른 index의 B+Tree의 리프노드에는 index_key + PK가 있다. PK B+Tree로 가기 위한 길을 안내한다.
    - 즉, select 문을 실행 했을 때, 가능한 인덱스에 대해 옵티마이저가 비용을 계산하고 비용이 적게드는 인덱스를 선택해 해당 인덱스의 B+Tree를 탐색하는 것이다.
  - 내부노드는 n개의 key와 n+1개의 포인터를 값으로 갖는다. 이 포인터는 다음으로 이동할 노드번호(page_id)이다.
  
  내부노드 예시
  ```
  keys:      [ 10 | 20 | 30 ]
  children:  [ p12 | p25 | p41 | p58 ]
  ```
  
  - index 값 5를 찾고자 할 때, 위 예시에서는 다음 노드번호(page_id)가 12인 노드로 찾아간다. 그리고 그것을 반복해 리프노드에서 값을 찾는다.
  