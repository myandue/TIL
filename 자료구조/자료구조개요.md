> **Database Internals 2장. B-트리 개요**를 읽고, 해당 장에 대해 정리하기에 앞서 자료구조라는 것에 대해 짚고 넘어가야겠다고 생각이 들었다. 
'노드'라는 것이 계속 쓰이는데 도대체 이 '노드'가 실제로 물리적으로 무엇을 의미하는 것인지,
이 자료구조라는건 어디서 누가 무엇을 위해 필요한건지,
주소값이라는 것은 또 논리적으로 물리적으로 무엇을 가리키는건지 이참에 꼭 정리하고자 했다.

우선 현재 머리에 얹혀져있는것만이라도 날아가기 전에 후다닥 나열해놓고 추후 수정하겠다.
B+Tree 구조 기준으로 정리한다.

### - 논리 개념 : 물리 개념 매핑
|논리 개념|물리 개념|
|:---|:---|
|B+Tree 노드|디스크 페이지(Page)|
|노드 포인터|page_id|
|트리 이동|page_id -> page_id|

- 페이지란 디스크 내에서 읽고 쓸 수 있는 가장 작은 물리 단위이며 고유 정수값인 id를 갖고 있다.
- 자료구조에서 정렬/탐색 시에 사용되는 그 '노드 번호'라는게 'page_id'라고 보면 된다.
- 노드는 key를 갖고 있는데, 이 key는 우리가 인지하고 있는 그 index에 해당한다. 즉, 정렬할 수 있는 대부분의 자료 타입이 key가 될 수 있다.(int, gitint, char, varchar, date, datetime 등)
- 우리(개발자)가 테이블을 생성하면 일반적으로 기본 인덱스인 PK가 있고, 추가적으로 secondary index를 생성할 수 있다.
  - 생성한 테이블의 각각의 index에 대해 B+Tree가 존재하게 된다.
  - 실제 데이터는 PK B+Tree의 리프노드에 저장돼있다.
  - 다른 index의 B+Tree의 리프노드에는 index_key + PK가 있다. PK B+Tree로 가기 위한 길을 안내한다.
  - 즉, select 문을 실행 했을 때, 가능한 인덱스에 대해 옵티마이저가 비용을 계산하고 비용이 적게드는 인덱스를 선택해 해당 인덱스의 B+Tree를 탐색하는 것이다.
- 내부노드는 n개의 key와 n+1개의 포인터를 값으로 갖는다. 이 포인터는 다음으로 이동할 노드번호(page_id)이다.

내부노드 예시
```
keys:      [ 10 | 20 | 30 ]
children:  [ p12 | p25 | p41 | p58 ]
```

- index 값 5를 찾고자 할 때, 위 예시에서는 다음 노드번호(page_id)가 12인 노드로 찾아간다. 그리고 그것을 반복해 리프노드에서 값을 찾는다.
