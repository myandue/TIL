# 2장. 느려진 서비스, 어디부터 봐야 할까
## 처리량
### - TPS
- transaction per second, 초당 트랜잭션 수
- 최대 TPS는 시스템이 처리할 수 있는 최대 요청 수를 의미한다.
- 동시에 들어오는 요청 수가 최대 TPS를 초과하면 서버는 초과한 요청을 나중에 처리한다.
- **최대 TPS를 초과하는 요청이 들어올 경우 사용자 입장에서는 응답 시간이 증가하는 문제를 겪게된다.**
- TPS를 높이기 위해 서버가 동시에 처리할 수 있는 요청 수를 늘리거나, 처리 시간 자체를 줄이는 방법을 고려한다.
- TPS를 확인하기 위해 모니터링 시스템을 활용한다. (ex. **스카우터**, **핀포인트**, **뉴렐릭** 등)

<br>

## 수직 확장과 수평 확장
- 개선안을 도출하기 전, 급한 불을 꺼야할 때 수직 확장과 수평 확장을 고려할 수 있다.
### - 수직 확장
- scale-up
- CPU, 메모리, 디스크 등의 자원을 증가시키는 것
### - 수평 확장
- scale-out
- 서버를 늘리는 방식이다
- 서버가 두 대 이상이면 트래픽을 알맞게 분산시켜주는 **로드 밸런서(load balancer)** 가 필요하다.
- 병목 지점을 파악하고 수행해야한다.
  - 성능 문제가 DB에 있는 것인데, DB를 사용하는 서버를 더 늘리면 더 악화될 뿐이다.
  - 마찬가지로 문제 발생 지점이 외부 API인데 이 경우에 우리 서버를 늘려봤자이다.

<br>

## DB 커넥션 풀
- DB를 사용(쿼리 실행)하기 위해서는 DB와 연결하고 종료하는 과정이 필요하다. 그리고 해당 과정이 소요 시간의 큰 비중을 차지한다.
- 때문에, DB 커넥션 풀에 미리 DB와 연결된 커넥션들을 준비해놓고 그것을 가져다 쓰는 것이다.
### - 커넥션 풀 크기
- 트래픽의 패턴에 맞추어 커넥션풀의 최소 크기와 최대 크기를 지정한다.
- DB의 상태를 고려하지 않고 무턱대고 크기를 늘리면 DB에 부하가 가해지고, 쿼리 실행 시간이 급격히 증가할 수 있으므로 주의한다.
### - 커넥션 대기 시간
- 풀에 사용할 수 있는 커넥션이 없을 때 커넥션을 얻기 위해 기다릴 수 있는 최대 시간인 대기 시간을 설정할 수 있다.
- 대기 시간이 길면, 응답 시간이 길어지고 일반적으로 이 경우에 유저는 재요청을 한다. 이럴 경우 요청이 쌓여 서버에 부하가 가해진다. 대기 시간을 짧게 가져가고 에러를 반환하는게 오히려 낫다.

<br>

## 서버 캐시
- cache, 일종의 (키, 값) 쌍을 저장하는 Map과 같은 형태의 데이터 저장소.
### - 적중률과 삭제 규칙
- 적중률 hit rate, 캐시가 얼마나 효율적으로 사용되는지 파악할 수 있는 지표.
- 적중률 = 캐시에 존재한 건수 / 캐시에서 조회를 시도한 건수
- 적중률이 높을수록 DB와의 연동이 줄어들고 곧 응답 시간 감소, 처리량 증가, DB 부하 감소로 이어진다.
- 물론 또한 메모리 자원을 사용하기 때문에 무작정 많은 데이터를 저장할 수는 없다.
- 새 데이터를 저장하기 위해 기존의 데이터를 제거한다.
  - LRU(Least Recently Used): 가장 오래 전에 사용된 데이터를 제거한다.
  - LFU(Least Frequently Used): 가장 적게 사용된 데이터를 제거한다.
  - FIFO(First In First Out): 먼저 추가된 데이터를 먼저 삭제한다.
### - 로컬 캐시와 리모트 캐시
- 로컬(local) 캐시
  - 서버 프로세스와 동일한 메모리를 캐시 저장소로 사용한다.
  - 빠르지만 데이터 크기에 제한이 있다.
  - 서버 프로세스를 재시작 할 시에 캐시 데이터가 모두 삭제된다.
- 리모트(remote) 캐시
  - 별도의 메모리를 사용한다.
  - 서버와 네트워크 통신을 해야해서 상대적으로 속도가 느리지만, 수평확장 할 수 있다.
  - 또한, 서버 프로세스를 재시작하더라도 캐시 데이터를 유지할 수 있다.
  - 레디스(Redis)가 이에 해당한다.
### - 캐시 사전 적재
- 트래픽이 순간적으로 급증하는 패턴을 보일 때, 미리 캐시 데이터를 저장해 놓을 수 있다.
- 예로, 정기적으로 이달의 요금을 푸시 알림 보내는 경우 알림 발송 후 사용자가 급증해 해당 정보를 조회할 것이므로, 해당 요금 정보를 미리 캐시 데이터로 저장해놓는 것이다.

<br>

## 가비지 컬렉터와 메모리 사용
- 가비지 컬렉터(Garbage Collector)
  - 사용이 끝난 객체를 힙 메모리에서 바로 삭제하지 않고 정해진 규칙에 따라 사용하지 않는 메모리를 찾아서 반환한다.
- 자바, Go, 파이썬 등의 언어는 가비지 컬렉터를 사용한다.
- 개발자가 메모리를 직접 관리해야 하는 부담을 줄여주지만, 응답 시간에 영향을 줄 수 있다. 자바의 경우 가비지 컬렉터가 실행되는 동안 애플리케이션의 실행이 일시 중단된다.
- 메모리가 클 경우, GC가 제거해야 할 미사용 객체를 탐색하는 데에 시간이 오래 걸린다. 때문에 힙 메모리 크기를 마냥 키워서는 안된다.
- 한 번에 대량으로 객체를 생성하는 것을 주의해야 한다.
  - 조회 범위를 제한한다.
  - 파일 다운로드와 같은 기능을 구현할 때는 스트림을 활용한다.

<br>

## 응답 데이터 압축
- 응답 데이터를 압축해 응답 시간을 감소시킬 수 있다.
- 응답 데이터 압축은 시간 뿐 아니라 비용에도 영향을 준다.

<br>

## 정적 자원
- 정적 자원은 전체 트래픽에서 상당한 비중을 차지한다.
- 동일한 페이지에 들어갈 때마다 같은 이미지나 JS 파일을 매번 다운로드하면 서버 입장에서 좋을 게 없다.
### - 브라우저 캐시
- 클라이언트 캐시를 활용해 같은 url에서의 정적 자원을 반복해서 요청하는 것을 방지한다.
- 예로, 응답 헤더에 `Cache-Control: max-age=60` 를 지정해줄 경우, 같은 주소를 60초 이내에 다시 요청하면 로컬에 보관한 데이터를 사용해 표시하는 것이다.
### - CDN
- Content Delivery Network(콘텐츠 전송 네트워크)
- 콘텐츠를 제공하기 위한 별도의 네트워크이다.
- 대표적인 서비스: Amazon CloudFront, Akamai, Cloudflare 등
- 사용자는 CDN이 제공하는 URL을 통해 콘텐츠에 접근한다. CDN 서버에 요청 콘텐츠가 없을 경우 오리진 서버에서 읽어와 제공하고 캐시에 보관한다.

<br>

## 대기 처리
- 콘서트 예매와 같이 사용자가 순간적으로 폭증할 경우 대기 처리를 한다.
- 수용할 수 있는 수준의 트래픽만 받아들이고 나머지는 대기하라고 안내하는 것이다.

<br>

# 3장. 성능을 좌우하는 DB 설계와 쿼리 
## 풀 스캔(full scan)
- 풀 스캔은 테이블의 모든 데이터를 순차적으로 읽는 것을 말한다. 보통 쿼리의 where 절에 있는 조건에 대응하는 인덱스가 없을 때 풀 스캔이 발생한다.
- 데이터 개수가 늘어나면 어느 순간 응답 시간이 기하급수적으로 증가하게 되므로 DB를 설계할 때는 풀 스캔 발생 가능성을 항상 염두에 두어야 한다.

<br>

## 조회 트래픽을 고려한 인덱스 설계
- 풀 스캔이 발생하지 않도록 조회 패턴을 기준으로 인덱스를 설계해야 한다.
- where 절의 조건에 해당하는 컬럼을 포함한 인덱스를 생성해야 한다.
### - 선택도를 고려한 인덱스 칼럼 선택
- 선택도, selectivity: 특정 칼럼의 고유한 값 비율을 나타낸다. 선택도가 높을수록(해당 컬럼에 고유값이 많을수록) 인덱스 효율이 높아진다.
- 선택도가 낮아도 인덱스 컬럼으로 적합한 상황도 있다.
  - 예로, 작업 큐를 구현한 테이블의 status 컬럼은 W, P, C 세 값을 갖는다. 선택도가 매우 낮다.
  - 하지만 작업 큐를 처리하는 코드는 status 칼럼값이 W인 데이터를 조회한다.
  - status 값으로 W를 가진 데이터는 전체 데이터에서 극히 낮은 비율을 갖는다. 때문에 status 컬럼을 인덱스로 추가해야한다.

<br>

## 몇 가지 조회 성능 개선 방법
- 인덱스 외의 조회 성능 개선안
### - 미리 집계하기
- 어떤 게시글 목록을 조회할 경우, 각 게시물의 답변 수와 좋아요 수를 같이 보여주는 경우가 많다.
- 이 경우 목록 조회 시, 서브쿼리로 count 를 사용하는데 이 또한 추후 성능 문제를 야기하게 된다.
- 해당 cnt를 아예 해당 게시글의 컬럼으로 추가해놓고, 답변/좋아요가 생성될 때 게시글을 update 하는 방식으로 미리 집계하는게 낫다.
- 비정규화?
  - "정규화는 관계형 데이터베이스의 설계에서 데이터 중복을 줄이고 데이터 무결성을 개선하기 위해 데이터를 정규형에 맞도록 구조화하는 프로세스를 뜻한다. 데이터베이스 정규화의 목표는 이상이 있는 관계를 재구성하여 작고 잘 조직된 관계를 생성하는 것에 있다."
  - 위 예시에서 cnt 컬럼을 추가하는 것은 데이터를 중복하는 것이고, 또한 실제 개수와 불일치 할 수 있는 무결성이 깨지는 문제가 발생할 수 있다.
  - 하지만 위의 예시에서는 약간의 불일치는 큰 문제가 되지 않는다. 서비스에서 중요한 부분이 어디인지를 파악해야한다.

<br>

 ## 이번 장을 읽고
- 인덱스에 대해 큰 고민을 해본적이 없었는데, 많은 것을 배운 장이었다.
- 인덱스 지정에 정답은 없고, 서비스의 특성, 조회 기능의 패턴 등등을 고려해 인덱스를 설계해야 한다.
- 또한, 인덱스는 조회 속도를 빠르게 해주지만 데이터 추가, 변경, 삭제 시에는 인덱스 관리에 따른 비용이 추가되고 메모리와 디스크 사용량이 함께 증가하기 때문에, 새로운 인덱스를 추가해야하는 상황에서는 기존의 인덱스를 꼭 살피고 새로운 조회 기능에 기존의 인덱스를 적용시킬 방안은 없을지 또한 검토해봐야한다.
- 답변 수, 좋아요 수 같은 예시도 일하면서 많이 고민했던 부분이었다. 서브쿼리로 Count 해서 보일 수 있는데 굳이 컬럼을 추가해야하나 라는 생각을 수십번은 했었는데, 나는 그동안 무조건적인 정답이 존재하며 그것만을 찾으려고 했었음을 깨달았다.

<br>

# 4장. 외부 연동이 문제일 때 살펴봐야 할 것들
## 타임아웃
- 외부 서비스를 이용할 때, 해당 연동에 타임아웃을 지정한다. 적절한 타임아웃을 설정하지 않으면, 외부 서비스 응답이 지연될 경우 자사 서비스의 서버에도 부하가 걸리게 된다.
### - 2가지 타임아웃: 연결 타임아웃, 읽기 타임아웃
- API 연동의 통신 과정 중 첫 번째 단계는 네트워크 연결 시도 단계이다. 해당 단계에서 연결 대기 시간을 제한 하도록 설정하는 것이 연결 타임아웃(connection timeout)이다.
- 연결 후 요청을 전송하고 응답을 기다리는데, 해당 응답에 대한 대기 시간을 제한 하는 것이 읽기 타임아웃(read timeout)이다.
- 읽기 타임아웃의 경우 실제 요청은 이미 해당 서버로 들어간 것이기 때문에, 응답 대기 시간을 너무 짧게 가져가면 해당 요청의 성공 여부와 무관하게 에러를 발생시킬 수 있으므로 유의해서 시간을 설정해야 한다.

<br>

## 재시도
- 외부 연동에 실패했을 때 횟수와 간격을 설정하여 재시도를 해볼 수 있다.
### - 재시도 가능 조건
- 조건
  - 단순 조회 기능
  - 연결 타임아웃
  - 멱등성(idempotent)을 가진 변경 기능
- 위에 읽기 타임아웃 파트에서 말한 것 처럼, 읽기 타임아웃에서는 해당 요청의 실제 성공 여부를 파악할 수가 없다. 때문에 읽기 타임아웃의 경우에 무작정 재시도 해서는 안된다. 요청이 두 번 이상 발생하게 될 수 있다.

<br>

## 동시 요청 제한
- 연동 서비스가 한 번에 처리할 수 있는 동시 요청 수가 적을 경우, 애초에 우리 서버에서 처리 가능한 요청 외의 요청들은 바로 에러로 응답한다. 503(Service Unavailable) HTTP 상태 코드를 사용해 과부하 상황임을 클라이언트에게 알린다.

<br>

## 서킷 브레이커
- 연동 서비스에 장애가 지속될 경우, 애초에 요청을 해당 서비스로 보내지 않도록 차단해주는 역할을 한다.
- 닫힘(Closed), 열림(Open), 반 열림(Half-Open)의 상태를 갖는다.
  - 평소에는 닫힘 상태이다.
  - 연동 서비스에 요청을 전달하는데, 오류가 발생하기 시작하면 지정한 임계치를 초과했는지 확인한다. (요청 대비 오류 발생 비율)
  - 임계치를 초과하면 열림 상태가 되어 연동 요청을 수행하지 않고 바로 에러 응답을 반환한다.
  - 열림 상태는 지정된 시간 동안 유지 된 후, 반 열림 상태로 전환된다.
  - 반 열림 상태에서 일부 요청에 한해 연동을 시도하고, 결과에 따라 닫힘/열림 상태로 전환한다.
 
<br>

# 5장. 비동기 연동, 언제 어떻게 써야 할까
- 외부 서비스를 연동할 때, 해당 서비스의 응답 시간이 길어지게 되면 전체 응답 시간이 길어지게 된다. 따라서, 외부 연동 결과가 꼭 필요한 것이 아니라면 비동기 방식으로 연동하는 것을 고려해본다.
- 다음과 같은 특징을 가지는 기능의 경우 비동기 연동 처리를 생각해본다.
  - 연동에 약간의 시차가 생겨도 문제가 되지 않는다. (ex. 주문 알림 푸시)
  - 실패했을 때 재시도가 가능하다. (ex. 인증 번호 받기)
  - 실패했을 때 나중에 수동으로 처리할 수 있다. (ex. 컨텐츠 등록시 검색에 노출)
  - 실패했을 때 무시해도 되는 기능이다. (ex. 주문 알림 푸시)
## 별도 스레드로 실행하기 
- 비동기 기능을 별도의 스레드 내에서 실행하는 것이다. 해당 스레드의 결과를 기다리지 않고 응답을 반환한다.
- 오류 처리에 더 신경 써야 한다. 응답을 기다리는 것이 아니기 때문에 해당 스레드의 익셉션이 전파되지 않는다. 별도 스레드로 실행되는 코드는 내부에서 오류를 직접 처리해야 한다.

<br>

## 메시징
- flow
  - 시스템 A가 시스템 B에 데이터를 전달하고자 한다. (A: 생산자/게시자(Producer/Publisher), B: 소비자/구독자(Consumer/Subscriber)
  - 시스템 A는 전달할 데이터를 가진 메시지를 생성해, 메시징 시스템에 전송한다.
  - 메시징 시스템은 해당 메시지를 시스템 B에 전달한다.
  - 시스템 B는 전달받은 데이터를 이용해 필요한 작업을 한다.
- 데이터를 전달하는 쪽과 전달 받는 쪽이 서로 영향을 주고 받지 않는다는 장점이 있다.
- 확장이 용이하다는 장점이 있다. 같은 데이터를 다른 시스템(C)이 이용하고자 할 때 전달하는 시스템(A)을 건들 필요 없이, 추가되는 시스템(C)을 메시징 시스템에 연결하면 된다.
- 카프카, 래빗MQ, 레디스 pub/sub 등이 있다.
### - 메시지 종류: 이벤트와 커맨드
- 이벤트 메시지는 '주문함', '로그인에 실패함'과 같이 말 그대로 이벤트 발생을 알린다. 소비자가 특정되어 있지 않다.
  - 예를들어, '주문함' 메시지는 알림 서비스와 주문 서비스가 소비할 수 있다.
- 커맨드 메시지는 '포인트 지급하기', '로그인 차단하기'와 같이 무언가를 요청하는 메시지다. 특정 소비자 서비스가 해당 메시지를 수신한다.
  - 예를들어, '포인트 지급하기'는 다른 어떤 서비스도 아닌 포인트 서비스만이 소비한다.
 
<br>

## 트랜잭션 아웃박스 패턴
- 메시징 시스템이 트랜잭션 내에 존재하면 롤백 될 경우에 잘못된 메시지 전송이 발생할 수 있다. 때문에, DB 트랜잭션이 완료된 후 메시지를 전송한다.
- 하지만 이 또한 완벽하진 않기 때문에 메시지 데이터 자체가 유실되지 않도록 DB에 저장하는 '트랜잭션 아웃박스 패턴(Transactional Outbox Pattern)'을 활용한다.
- 해당 패턴은 하나의 DB 트랜잭션 내에서 다음 2가지 작업을 수행한다.
  - 실제 업무 로직에 필요한 DB 변경 작업을 수행한다.
  - 메시지 데이터를 아웃박스 테이블에 추가한다.
- 별도의 메시지 중계 프로세스가 아웃박스 테이블을 주기적으로 읽어 메시징 시스템으로 전달하고, 정상적으로 전달 완료 됐음을 해당 테이블의 해당 데이터에 표기해둔다.

<br>

## CDC(Change Data Capture)
- 변경된 데이터를 추적하고 판별해서 변경된 데이터로 작업을 수행할 수 있도록 하는 소프트웨어 설계 패턴
- flow
  - INSERT, UPDATE, DELETE 쿼리 실행에 의해 DB의 데이터가 변경된다.
  - DB는 변경된 데이터를 CDC 처리기에 전송한다. 커밋된 데이터만 변경된 순서에 맞게 전달한다.
  - CDC 처리기는 소비자 시스템에게 변경된 데이터를 전파한다. 데이터 그대로 전파할 수도 있고, 가공/변환해서 전파할 수도 있다.
- CDC는 정확한 의미의 이벤트를 전달하는 것이 아니라 말 그대로 데이터가 변경됐다는 사실와 데이터 내용을 전한다.
- CDC 처리기가 변경 데이터를 메시징 시스템에 전달하면 소비자 확장이 용이하다.

<br>

# 6장. 동시성, 데이터가 꼬이기 전에 잡아야 한다
- 저자가 동시성 프로그래밍은 책 한 권 분량으로 다뤄야 할 만큼 방대한 주제라고 먼저 던졌는데, 정말이지 뭔 말인지 너무나도 알겠다..
## 경쟁 상태
- **race condition**, 여러 스레드가 동시에 공유 자원에 접근할 때, 접근 순서에 따라 결과가 달라지는 상황을 말한다.

<br>

## 프로세스 수준에서의 동시 접근 제어
### - 잠금(lock)을 이용한 접근 제어
- 잠금을 사용해 공유 자원에 접근하는 스레드를 한 번에 하나로 제한한다.
- 잠금은 한 번에 한 스레드만 획득할 수 있고, 획득 시도 시 이미 소진됐으면 대기한다.
- 잠금 사용을 마친 스레드는 잠금을 해제하고 대기 중이던 스레드가 획득한다.

### - 읽기 쓰기 잠금
- 특정 자원에 대해 읽기의 경우 다수가 접근해도 문제되지 않는다.
- 쓰기의 경우 한 스레드만이 접근해야한다.
- 읽기/쓰기가 같이 접근해도 안된다.
- 해서, 읽기 혹은 쓰기로 잠금은 하나만이 존재하고, 읽기 잠금의 경우 여러 스레드가 구할 수 있으며 쓰기 잠금의 경우 한 스레드만 구할 수 있다.

<br>

## DB와 동시성
### - 선점(비관적) 잠금
- 데이터에 먼저 접근한 트랜잭션이 잠금을 획득하는 방식이다.
### - 비선점(낙관적) 잠금
- 잠금을 사용하지 않는다.
- 데이터를 조회한 시점의 값과 수정하려는 시점의 값이 같은지 비교하는 방식으로 동시성 문제를 처리한다.
- 보통 정수 타입의 버전 컬럼을 사용한다.
  - select 쿼리 실행 시 version 컬럼을 함께 조회한다.
  - 로직을 수행한다.
  - update 쿼리 실행 시 `version = version + 1`을 하며, where 절에 `version = [select 쿼리 실행시 얻었던 version 값]`을 추가한다.
  - update 결과 변경 행 수가 0개이면 트랜잭션을 롤백한다.
- 잠금을 구하기 위한 대기 과정이 없기 때문에 선점 잠금 대비 (실패)응답이 더 빠르다.
### - 외부 연동과 잠금
- 트랜잭션 중간에 외부 연동이 포함되어 있다면 선점 잠금 사용을 고려한다.
- 비선점 잠금의 경우 예시로, '주문 조회 -> 취소 요청 -> 결제 취소(외부 연동) 성공 -> 주문 상태 변경' 에서 외부 연동 타이밍에 해당 데이터에 접근한 다른 스레드가 해당 데이터의 값을 이미 수정했다면 실제 결제 취소는 완료 됐는데 주문 상태 변경은 실패하기 때문이다.

<br>

## 잠금 사용 시 주의 사항
### - 잠금 해제하기
- 잠금 획득 후 해제하지 않는다면 잠금 시도 스레드들이 무한정 대기하게 된다.
- try-finally 구조를 사용해 finally 블록에서 잠금 해제 코드를 꼭 작성해준다.
### - 대기 시간 지정하기
### - 교착 상태(deadlock) 피하기
- 두 자원에 대한 잠금이 필요할 경우 주의한다.
- 특정 작업에서 A,B 자원에 대한 잠금이 필요할 때, 스레드1이 A자원 잠금을 획득했고 스레드2가 B자원 잠금을 획득했다면 각 스레드는 B/A 자원에 대한 잠금을 획득하기 위해 무한 대기하게 되는 교착 상태에 빠지게 된다.
- 이를 해소하기 위해,
  - 잠금 대기 시간을 제한할 수 있다.
  - 잠금 순서를 지정한다. 위 예시에서 무조건 A 자원에 대한 잠금을 획득해야만 한다면 스레드2가 B 잠금을 획득하지 않고 A 잠금 획득을 대기하게 된다.

<br>

# 7장. IO 병목, 어떻게 해결하지
- 입출력(IO)을 진행하는 동안 스레드는 대기한다. 이를 스레드가 블로킹(blocking) 됐다고 한다.
- 이렇게 블로킹 된 시간이(입출력에 소요되는 시간이) 코드를 실행하는 시간보다 훨씬 길다.
- 스레드가 블로킹 되면 해당 스레드를 실행하는 CPU가 아무것도 하지 않고 낭비되기 때문에, 그를 해소하기 위해 동시에 실행되는 스레드 개수를 늘린다.
  - 하지만 스레드는 메모리를 사용하기 때문에 스레드를 늘린대도 메모리가 병목이 된다.
  - 메모리 문제 뿐 아니라, 컨텍스트 스위칭에 사용되는 시간 또한 증가한다.
  - 컨텍스트 스위칭: 운영체제는 여러 스레드를 번갈아 가면서 CPU에 할당한다. 이 전환 과정을 의미한다.
## 가상 스레드로 자원 효율 높이기
- os가 관리하는 스레드가 아니라 언어의 런타임이 관리하는 스레드를 경량 스레드라고 한다.
- 자바의 경우,
  - JVM은 OS 스레드에 1:1로 대응하는 플랫폼 스레드들로 구성된 풀을 갖는다.
  - 플랫폼 스레드보다 더 작은 자원(메모리)을 사용하는 가상 스레드들을 갖는다.
### - 네트워크 IO와 가상 스레드
- 가상 스레드는 실행하는 과정에서 블로킹되면 플랫폼 스레드와 언마운트되고 실행이 멈춘다.
- 이 때, 언마운트된 플랫폼 스레드는 실행 대기 중인 다른 가상 스레드와 연결된 뒤 실행을 재개한다.
### - 가상 스레드와 성능
- 가상 스레드는 작업의 성능 자체를 올려주는 것이 아니라 CPU를 효율적으로 사용하게 도와주는 것이기 때문에, CPU 중심 작업보다 IO 중심 작업에 효과적이다.
- 즉, 블로킹연산이 있을 때에 가상스레드가 효과적이다.
- 또한, 가상 스레드의 수가 플랫폼 스레드의 수보다 많아야만 가상 스레드 사용의 이유가 있다.

<br>

## 논블로킹 IO로 성능 더 높이기
- 논블로킹 IO는 입출력이 끝날 때까지 스레드가 대기하지 않는다.
- 논블로킹 파트는 추상적으로는 어떤 느낌인지 알겠다만, 실제 동작과 같은 것은 전혀 이해하지 못했다. 따로 더 공부가 필요한 파트이다.. TODO..

<br>

# 8장. 실무에서 꼭 필요한 보안 지식
## 인증과 인가
- **인증, Authentication**: 사용자가 누구인지 확인하는 과정
- **인가, Authorization**: 사용자에게 자원에 접근할 수 있는 권한을 부여하는 것
### - 인가와 접근 제어 모델
- 접근 제어(Access Control) 모델: 사용자가 접근할 수 있는 기능(또는 자원)을 관리하기 위한 모델
  - 역할 기반 접근 제어(Role-Based Access Control, RBAC) 모델
  - 속성 기반 접근 제어(Attribute-Based Access Control, ABAC) 모델: 예를들어 사용자의 IP 주소에 따라 특정 기능의 접근을 허용/제한 한다

<br>

## 데이터 암호화
### - 단방향 암호화
- 복호화 할 수 없는 암호화 방식이다.
- 해시 함수를 사용해서 데이터를 해시 값으로 변환한다.
- 해시 함수 알고리즘에는 SHA-256, MD5, BCrypt 등이 있다.
- 원본 데이터를 유추하기 어렵게 하기 위해 원본 데이터가 조금만 달라도 완전히 다른 해시 값을 생성한다.
- 해시 값이 같다면 같은 데이터라고 간주한다.
- 같은 해시 알고리즘을 사용하면 동일한 원본 데이터에 대해 항상 동일한 해시 값이 생성된다. 이 특성은 해시 값이 유출됐을 때 원본을 유추하기 쉽게 만든다. 이렇게 원본 문자열과 해시 값을 미리 계산해서 만든 표를 레인보우 테이블(rainbow table)이라 한다.
- 이 보안 취약점을 보완하기 위해 솔트(salt)를 사용한다. 임의의 값인 솔트를 함께 사용해 원본 데이터에 변화를 주고 해시 함수를 사용하는 것이다.
### - 양방향 암호화
- 키(key)를 사용해 암호화/복호화를 한다.
- 암호화/복호화에 같은 키를 사용하는 대칭 키 방식이 있고, 다른 키를 사용하는 비대칭 키 방식이 있다.
- 비대칭 키의 경우 공개 키와 개인 키 쌍을 갖고 암/복호화를 한다.

<br>

## HMAC을 이용한 데이터 검증
- **Hash-based Message AuthenticationCode**, 메시지의 무결성과 인증을 보장하기 위해 사용하는 암호화 기술이다.
- 서버가 클라이언트로부터 데이터를 전달받을 때, 해당 메시지가 위변조되지 않았다는 것을 확인할 수단이 필요하며, 이 때 HMAC을 주로 사용한다.
- flow
  - 메시지의 발신자와 수신자는 둘만 알고 있는 비밀 키를 공유한다.
  - 메시지 발신자는 메시지를 비밀 키로 해싱해서 생성한 MAC(메시지 인증 코드)를 원본 메시지와 함께 수신자에게 전송한다.
  - 수신자는 수신한 메시지와 비밀 키를 이용해 MAC을 다시 생성한 뒤, 발신자가 보낸 MAC과 비교한다. 두 값이 같으면 메시지 무결성을 보장할 수 있다.
- HMAC은 단순함과 효율성이 장점이지만, 그만큼 비밀 키 관리에 신경써야한다.

<br>

# 9장. 최소한 알고 있어야 할 서버 지식
## OS 계정과 권한
### - sudo로 권한 주기
- 일반적으로 운영체제의 root 권한은 일부 인프라 담당자만 갖고, 개발자는 일반 계정에 대한 권한만 갖는다.
- 개발자에게도 root 권한이 필요할 때가 있는데, 이럴때 sudo 명령어를 사용하면 다른 사용자의 권한으로 프로그램을 실행할 수 있다.
- sudo 명령어로 실행할 수 있는 명령어는 별도 설정 파일로 관리한다. (`/etc/sudoers` 혹은 `/etc/sudoers.d`)
- 모든 명령어를 실행할 수 있는 권한을 부여하는 것은 root나 다름없기때문에 ALL이 아닌 특정 명령어만 실행할 수 있는 권한을 부여해야한다.

<br>

## 백그라운드 프로세스
- 포그라운드 프로세스는 터미널에 연결된 프로세스로, 사용자와 상호작용한다.
- 포그라운드 프로세스는 사용자와 터미널의 연결이 끊기면 종료된다.
- 서버 프로세스는 항상 실행되어 있어야하므로, 백그라운드 프로세스로 실행한다.
- 백그라운드 프로레스는 터미널과 연결되지 않은 프로세스를 말하며, 사용자와 상호작용할 수 없다.
- 리눅스에서 프로세스를 백그라운드로 실행하려면 명령어 뒤에 &을 붙인다.
  - ex. `$ java -Dserver.port=9090 -jar server.jar &`
- 사용자가 로그아웃하면 터미널에서 실행한 백그라운드 프로세스가 함께 종료될 수 있다. 터미널을 종료해도 계속 실행되게 하려면 `nohup` 명령어를 붙인다
  - ex. `$ nohup java -Dserver.port=9090 -jar server.jar &`
- 해당 프로세스에서 출력되는 내용을 별도의 로그파일로 보관하고 싶다면 다음과 같이 입력한다.
  - `$ nohup java -Dserver.port=9090 -jar server.jar > server.log 2>&1 &`
  - `2>&1`: 2는 표준 오류를 의미하며 &1은 표준 출력을 의미한다. 표준 오류를 표준 출력과 동일한 경로로 전달하라는 의미이다.

<br>

## 디스크 용량 관리
- 일반적으로 서버 프로그램에서 디스크 용량과 관련된 파일은 다음 2가지다.
  - 로그 파일
  - 파일 저장(임시 파일 등)
- 로그 파일의 경우 주기적으로 압축/제거를 해준다.

<br>

## 시간 맞추기
- 서버를 운영할 때는 시간 동기화에 신경 써야 한다.
- 서버 시간이 틀어지는 것을 방지하려면 chrony나 ntp 같은 서비스를 이용해서 주기적으로 서버 시간을 맞춰야 한다.
- 최초에 서버를 구성할 대 시간 동기화를 꼭 활성화해주도록 한다.

<br>

## 크론으로 스케줄링하기
- 일회성 작업을 스케줄링해야 할 때는 cron 대신 at 명령어를 사용한다. at 명령어는 지정한 일자와 시간에 명령어를 실행하는 기능을 제공한다.
  - cron에서 돌릴 기능을 테스트할 때 임의로 cron에 지정했던 시간을 '현재시간+1분' 이런식으로 재설정해서 테스트했던적이 많다. 그래서 기록해둔다..

<br>

## alias 등록하기
- 자주 사용하는 명령어를 alias 등록해두면 편리하다.
- ex. `$ alias cdweb='cd /var/www/html'`
  - 위와 같이 등록해놓으면, `$ cdweb` 명령어를 입력했을 때 해당 명령어가 실행되어 해당 디렉토리로 이동하게 된다.
  - 이 방식은 현재 터미널 세션에만 적용하는 방식이다. (= 터미널 재시작 시에 리셋)
- 매번 alias를 자동으로 적용하고 싶다면, 쉘의 구성파일에 alias를 등록하면 된다.
  - 예를들어, 로키 리눅스, CentOS, 우분투 같은 경우에 홈 디렉토리에 위치한 .bashrc 파일 하단에 alias 설정을 추가한다.
  - ```
    # .bashrc
    # Source global definitions
    if [ -f /etc/bashrc ]; then
            . /etc/bashrc
    fi
    # alias
    alias cdweb='cd /var/www/html'
    ```

<br>

# 10장. 모르면 답답해지는 네트워크 기초 
## 노드, 네트워크, 라우터
- **노드, node**: 데이터를 송수신하는 모든 장치를 노드라고 표현한다.
- **네트워크, network**": 각 노드가 서로 데이터를 주고받기 위해 연결된 시스템을 네트워크라고 한다.
  - 예로, 가정에서 사용하는 공유기에 연결된 장치들을 들 수 있다. 공유기에 연결된 휴대폰, 컴퓨터 등은 하나의 네트워크를 구성한다.
- **패킷, packet**: 노드가 네트워크를 통해 전송하는 데이터 단위이며, 패킷은 헤더와 페이로드로 구성된다.
- **라우터, router**: 서로 다른 네트워크 간에 패킷을 전송하는 역할을 한다.

<br>

## IP 주소와 도메인
- **DNS, Domain Name System**: 도메인 이름과 IP 주소로 변환하는 체계
### - 공인 IP와 사설 IP
- 공인(public) IP
  - 인터넷에서 접근 가능한 IP 주소
  - 인터넷에 접속하는 모든 네트워크에 적용되는 주소 (= 서로 같은 주소를 가질 수 없다)
  - 공인 IP 주소를 가진 노드는 누구나 연결할 수 있다.
- 사설(private) IP
  - 네트워크 내부에만 적용되는 IP 주소
  - 네트워크 외부에서 접근할 수 없다.
  - 공유기에 연결된 휴대폰, 태블릿, 컴퓨터가 사설 IP 주소를 갖는다.
  - 네트워크가 다르다면 같은 주소를 가질 수 있다. 사설 IP는 네트워크 내부에서만 고유하면 된다.
 
<br>

## 프로토콜과 TCP, UDP, QUIC
- **프로토콜, protocol**: 네트워크 상에서 두 노드가 데이터를 주고받기 위해 정의한 규칙
- 네트워크는 여러 계층으로 구성되며 각 계층마다 사용하는 프로토콜이 존재한다.
- TCP/IP 4계층 모델과 각 계층의 주요 프로토콜
  - 애플리케이션(application) 계층: HTTP, FTP, SMTP
  - 전송(transport) 계층: TCP, UDP
  - 인터넷(internet) 계층: IP
  - 네트워크 액세스(network access) 계층 (= 데이터 링크 계층 + 물리 계층)
### - TCP
- Transmission Control Protocol
- 연결 기반 프로토콜로, 두 노드간 연결이 우선이다.
- 두 노드가 연결을 맺기 위한 과정을 3-Way Handshake라고 부른다. (SYN -> SYN-ACK -> ACK)
- 패킷 순서를 보장하고 패킷 유실 시 재전송하는 기능을 제공한다.
- 이러한 신뢰성 때문에 애플리케이션 계층의 HTTP, SMTP와 같은 프로토콜이 TCP를 기반으로 동작한다.
### - UDP
- User Datagram Protocol
- 연결 과정 없이 바로 데이터를 전송한다.
- 데이터가 정상 전송됐는지 알 수 없고, 순서를 보장하지 않는다. -> 데이터 유실을 가정하고 사용해야한다.
- 속도가 TCP 대비 빠르다.
### - QUIC
- TCP의 신뢰성과 UDP의 빠른 속도를 합친 프로토콜
- UDP를 기반으로 한다.
- TCP처럼 연결관리 기능이 있는데, 데이터에 연결 ID를 포함시켜 두 노드 간의 연결을 유지한다.
- TCP의 경우, TCP 연결을 위한 3-Way Handshake + TLS(Transport Layer Security) 연결을 위한 TLS Handshake 의 연결 과정이 있다.
- QUIC의 경우, TLS를 통합함으로써 위 과정을 단축했다.
- HTTP/3 프로토콜이 QUIC를 기반으로 사용한다.
- (아직 직접 본적은 없지만 개발자 도구를 통해 protocol 값에 h3을 확인해볼 수 있다. QUIC도 따로 더 알아보고싶다.)
