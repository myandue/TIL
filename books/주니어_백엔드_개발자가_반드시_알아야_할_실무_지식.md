# 2장. 느려진 서비스, 어디부터 봐야 할까
## 처리량
### - TPS
- transaction per second, 초당 트랜잭션 수
- 최대 TPS는 시스템이 처리할 수 있는 최대 요청 수를 의미한다.
- 동시에 들어오는 요청 수가 최대 TPS를 초과하면 서버는 초과한 요청을 나중에 처리한다.
- **최대 TPS를 초과하는 요청이 들어올 경우 사용자 입장에서는 응답 시간이 증가하는 문제를 겪게된다.**
- TPS를 높이기 위해 서버가 동시에 처리할 수 있는 요청 수를 늘리거나, 처리 시간 자체를 줄이는 방법을 고려한다.
- TPS를 확인하기 위해 모니터링 시스템을 활용한다. (ex. **스카우터**, **핀포인트**, **뉴렐릭** 등)

<br>

## 수직 확장과 수평 확장
- 개선안을 도출하기 전, 급한 불을 꺼야할 때 수직 확장과 수평 확장을 고려할 수 있다.
### - 수직 확장
- scale-up
- CPU, 메모리, 디스크 등의 자원을 증가시키는 것
### - 수평 확장
- scale-out
- 서버를 늘리는 방식이다
- 서버가 두 대 이상이면 트래픽을 알맞게 분산시켜주는 **로드 밸런서(load balancer)** 가 필요하다.
- 병목 지점을 파악하고 수행해야한다.
  - 성능 문제가 DB에 있는 것인데, DB를 사용하는 서버를 더 늘리면 더 악화될 뿐이다.
  - 마찬가지로 문제 발생 지점이 외부 API인데 이 경우에 우리 서버를 늘려봤자이다.

<br>

## DB 커넥션 풀
- DB를 사용(쿼리 실행)하기 위해서는 DB와 연결하고 종료하는 과정이 필요하다. 그리고 해당 과정이 소요 시간의 큰 비중을 차지한다.
- 때문에, DB 커넥션 풀에 미리 DB와 연결된 커넥션들을 준비해놓고 그것을 가져다 쓰는 것이다.
### - 커넥션 풀 크기
- 트래픽의 패턴에 맞추어 커넥션풀의 최소 크기와 최대 크기를 지정한다.
- DB의 상태를 고려하지 않고 무턱대고 크기를 늘리면 DB에 부하가 가해지고, 쿼리 실행 시간이 급격히 증가할 수 있으므로 주의한다.
### - 커넥션 대기 시간
- 풀에 사용할 수 있는 커넥션이 없을 때 커넥션을 얻기 위해 기다릴 수 있는 최대 시간인 대기 시간을 설정할 수 있다.
- 대기 시간이 길면, 응답 시간이 길어지고 일반적으로 이 경우에 유저는 재요청을 한다. 이럴 경우 요청이 쌓여 서버에 부하가 가해진다. 대기 시간을 짧게 가져가고 에러를 반환하는게 오히려 낫다.

<br>

## 서버 캐시
- cache, 일종의 (키, 값) 쌍을 저장하는 Map과 같은 형태의 데이터 저장소.
### - 적중률과 삭제 규칙
- 적중률 hit rate, 캐시가 얼마나 효율적으로 사용되는지 파악할 수 있는 지표.
- 적중률 = 캐시에 존재한 건수 / 캐시에서 조회를 시도한 건수
- 적중률이 높을수록 DB와의 연동이 줄어들고 곧 응답 시간 감소, 처리량 증가, DB 부하 감소로 이어진다.
- 물론 또한 메모리 자원을 사용하기 때문에 무작정 많은 데이터를 저장할 수는 없다.
- 새 데이터를 저장하기 위해 기존의 데이터를 제거한다.
  - LRU(Least Recently Used): 가장 오래 전에 사용된 데이터를 제거한다.
  - LFU(Least Frequently Used): 가장 적게 사용된 데이터를 제거한다.
  - FIFO(First In First Out): 먼저 추가된 데이터를 먼저 삭제한다.
### - 로컬 캐시와 리모트 캐시
- 로컬(local) 캐시
  - 서버 프로세스와 동일한 메모리를 캐시 저장소로 사용한다.
  - 빠르지만 데이터 크기에 제한이 있다.
  - 서버 프로세스를 재시작 할 시에 캐시 데이터가 모두 삭제된다.
- 리모트(remote) 캐시
  - 별도의 메모리를 사용한다.
  - 서버와 네트워크 통신을 해야해서 상대적으로 속도가 느리지만, 수평확장 할 수 있다.
  - 또한, 서버 프로세스를 재시작하더라도 캐시 데이터를 유지할 수 있다.
  - 레디스(Redis)가 이에 해당한다.
### - 캐시 사전 적재
- 트래픽이 순간적으로 급증하는 패턴을 보일 때, 미리 캐시 데이터를 저장해 놓을 수 있다.
- 예로, 정기적으로 이달의 요금을 푸시 알림 보내는 경우 알림 발송 후 사용자가 급증해 해당 정보를 조회할 것이므로, 해당 요금 정보를 미리 캐시 데이터로 저장해놓는 것이다.

<br>

## 가비지 컬렉터와 메모리 사용
- 가비지 컬렉터(Garbage Collector)
  - 사용이 끝난 객체를 힙 메모리에서 바로 삭제하지 않고 정해진 규칙에 따라 사용하지 않는 메모리를 찾아서 반환한다.
- 자바, Go, 파이썬 등의 언어는 가비지 컬렉터를 사용한다.
- 개발자가 메모리를 직접 관리해야 하는 부담을 줄여주지만, 응답 시간에 영향을 줄 수 있다. 자바의 경우 가비지 컬렉터가 실행되는 동안 애플리케이션의 실행이 일시 중단된다.
- 메모리가 클 경우, GC가 제거해야 할 미사용 객체를 탐색하는 데에 시간이 오래 걸린다. 때문에 힙 메모리 크기를 마냥 키워서는 안된다.
- 한 번에 대량으로 객체를 생성하는 것을 주의해야 한다.
  - 조회 범위를 제한한다.
  - 파일 다운로드와 같은 기능을 구현할 때는 스트림을 활용한다.

<br>

## 응답 데이터 압축
- 응답 데이터를 압축해 응답 시간을 감소시킬 수 있다.
- 응답 데이터 압축은 시간 뿐 아니라 비용에도 영향을 준다.

<br>

## 정적 자원
- 정적 자원은 전체 트래픽에서 상당한 비중을 차지한다.
- 동일한 페이지에 들어갈 때마다 같은 이미지나 JS 파일을 매번 다운로드하면 서버 입장에서 좋을 게 없다.
### - 브라우저 캐시
- 클라이언트 캐시를 활용해 같은 url에서의 정적 자원을 반복해서 요청하는 것을 방지한다.
- 예로, 응답 헤더에 `Cache-Control: max-age=60` 를 지정해줄 경우, 같은 주소를 60초 이내에 다시 요청하면 로컬에 보관한 데이터를 사용해 표시하는 것이다.
### - CDN
- Content Delivery Network(콘텐츠 전송 네트워크)
- 콘텐츠를 제공하기 위한 별도의 네트워크이다.
- 대표적인 서비스: Amazon CloudFront, Akamai, Cloudflare 등
- 사용자는 CDN이 제공하는 URL을 통해 콘텐츠에 접근한다. CDN 서버에 요청 콘텐츠가 없을 경우 오리진 서버에서 읽어와 제공하고 캐시에 보관한다.

<br>

## 대기 처리
- 콘서트 예매와 같이 사용자가 순간적으로 폭증할 경우 대기 처리를 한다.
- 수용할 수 있는 수준의 트래픽만 받아들이고 나머지는 대기하라고 안내하는 것이다.

<br>

# 3장. 성능을 좌우하는 DB 설계와 쿼리 
## 풀 스캔(full scan)
- 풀 스캔은 테이블의 모든 데이터를 순차적으로 읽는 것을 말한다. 보통 쿼리의 where 절에 있는 조건에 대응하는 인덱스가 없을 때 풀 스캔이 발생한다.
- 데이터 개수가 늘어나면 어느 순간 응답 시간이 기하급수적으로 증가하게 되므로 DB를 설계할 때는 풀 스캔 발생 가능성을 항상 염두에 두어야 한다.

<br>

## 조회 트래픽을 고려한 인덱스 설계
- 풀 스캔이 발생하지 않도록 조회 패턴을 기준으로 인덱스를 설계해야 한다.
- where 절의 조건에 해당하는 컬럼을 포함한 인덱스를 생성해야 한다.
### - 선택도를 고려한 인덱스 칼럼 선택
- 선택도, selectivity: 특정 칼럼의 고유한 값 비율을 나타낸다. 선택도가 높을수록(해당 컬럼에 고유값이 많을수록) 인덱스 효율이 높아진다.
- 선택도가 낮아도 인덱스 컬럼으로 적합한 상황도 있다.
  - 예로, 작업 큐를 구현한 테이블의 status 컬럼은 W, P, C 세 값을 갖는다. 선택도가 매우 낮다.
  - 하지만 작업 큐를 처리하는 코드는 status 칼럼값이 W인 데이터를 조회한다.
  - status 값으로 W를 가진 데이터는 전체 데이터에서 극히 낮은 비율을 갖는다. 때문에 status 컬럼을 인덱스로 추가해야한다.

<br>

## 몇 가지 조회 성능 개선 방법
- 인덱스 외의 조회 성능 개선안
### - 미리 집계하기
- 어떤 게시글 목록을 조회할 경우, 각 게시물의 답변 수와 좋아요 수를 같이 보여주는 경우가 많다.
- 이 경우 목록 조회 시, 서브쿼리로 count 를 사용하는데 이 또한 추후 성능 문제를 야기하게 된다.
- 해당 cnt를 아예 해당 게시글의 컬럼으로 추가해놓고, 답변/좋아요가 생성될 때 게시글을 update 하는 방식으로 미리 집계하는게 낫다.
- 비정규화?
  - "정규화는 관계형 데이터베이스의 설계에서 데이터 중복을 줄이고 데이터 무결성을 개선하기 위해 데이터를 정규형에 맞도록 구조화하는 프로세스를 뜻한다. 데이터베이스 정규화의 목표는 이상이 있는 관계를 재구성하여 작고 잘 조직된 관계를 생성하는 것에 있다."
  - 위 예시에서 cnt 컬럼을 추가하는 것은 데이터를 중복하는 것이고, 또한 실제 개수와 불일치 할 수 있는 무결성이 깨지는 문제가 발생할 수 있다.
  - 하지만 위의 예시에서는 약간의 불일치는 큰 문제가 되지 않는다. 서비스에서 중요한 부분이 어디인지를 파악해야한다.

<br>

 ## 이번 장을 읽고
- 인덱스에 대해 큰 고민을 해본적이 없었는데, 많은 것을 배운 장이었다.
- 인덱스 지정에 정답은 없고, 서비스의 특성, 조회 기능의 패턴 등등을 고려해 인덱스를 설계해야 한다.
- 또한, 인덱스는 조회 속도를 빠르게 해주지만 데이터 추가, 변경, 삭제 시에는 인덱스 관리에 따른 비용이 추가되고 메모리와 디스크 사용량이 함께 증가하기 때문에, 새로운 인덱스를 추가해야하는 상황에서는 기존의 인덱스를 꼭 살피고 새로운 조회 기능에 기존의 인덱스를 적용시킬 방안은 없을지 또한 검토해봐야한다.
- 답변 수, 좋아요 수 같은 예시도 일하면서 많이 고민했던 부분이었다. 서브쿼리로 Count 해서 보일 수 있는데 굳이 컬럼을 추가해야하나 라는 생각을 수십번은 했었는데, 나는 그동안 무조건적인 정답이 존재하며 그것만을 찾으려고 했었음을 깨달았다.

<br>

# 4장. 외부 연동이 문제일 때 살펴봐야 할 것들
## 타임아웃
- 외부 서비스를 이용할 때, 해당 연동에 타임아웃을 지정한다. 적절한 타임아웃을 설정하지 않으면, 외부 서비스 응답이 지연될 경우 자사 서비스의 서버에도 부하가 걸리게 된다.
### - 2가지 타임아웃: 연결 타임아웃, 읽기 타임아웃
- API 연동의 통신 과정 중 첫 번째 단계는 네트워크 연결 시도 단계이다. 해당 단계에서 연결 대기 시간을 제한 하도록 설정하는 것이 연결 타임아웃(connection timeout)이다.
- 연결 후 요청을 전송하고 응답을 기다리는데, 해당 응답에 대한 대기 시간을 제한 하는 것이 읽기 타임아웃(read timeout)이다.
- 읽기 타임아웃의 경우 실제 요청은 이미 해당 서버로 들어간 것이기 때문에, 응답 대기 시간을 너무 짧게 가져가면 해당 요청의 성공 여부와 무관하게 에러를 발생시킬 수 있으므로 유의해서 시간을 설정해야 한다.

<br>

## 재시도
- 외부 연동에 실패했을 때 횟수와 간격을 설정하여 재시도를 해볼 수 있다.
### - 재시도 가능 조건
- 조건
  - 단순 조회 기능
  - 연결 타임아웃
  - 멱등성(idempotent)을 가진 변경 기능
- 위에 읽기 타임아웃 파트에서 말한 것 처럼, 읽기 타임아웃에서는 해당 요청의 실제 성공 여부를 파악할 수가 없다. 때문에 읽기 타임아웃의 경우에 무작정 재시도 해서는 안된다. 요청이 두 번 이상 발생하게 될 수 있다.

<br>

## 동시 요청 제한
- 연동 서비스가 한 번에 처리할 수 있는 동시 요청 수가 적을 경우, 애초에 우리 서버에서 처리 가능한 요청 외의 요청들은 바로 에러로 응답한다. 503(Service Unavailable) HTTP 상태 코드를 사용해 과부하 상황임을 클라이언트에게 알린다.

<br>

## 서킷 브레이커
- 연동 서비스에 장애가 지속될 경우, 애초에 요청을 해당 서비스로 보내지 않도록 차단해주는 역할을 한다.
- 닫힘(Closed), 열림(Open), 반 열림(Half-Open)의 상태를 갖는다.
  - 평소에는 닫힘 상태이다.
  - 연동 서비스에 요청을 전달하는데, 오류가 발생하기 시작하면 지정한 임계치를 초과했는지 확인한다. (요청 대비 오류 발생 비율)
  - 임계치를 초과하면 열림 상태가 되어 연동 요청을 수행하지 않고 바로 에러 응답을 반환한다.
  - 열림 상태는 지정된 시간 동안 유지 된 후, 반 열림 상태로 전환된다.
  - 반 열림 상태에서 일부 요청에 한해 연동을 시도하고, 결과에 따라 닫힘/열림 상태로 전환한다.
