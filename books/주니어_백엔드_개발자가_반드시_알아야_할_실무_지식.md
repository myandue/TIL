# 2장. 느려진 서비스, 어디부터 봐야 할까
## 처리량
### TPS
- transaction per second, 초당 트랜잭션 수
- 최대 TPS는 시스템이 처리할 수 있는 최대 요청 수를 의미한다.
- 동시에 들어오는 요청 수가 최대 TPS를 초과하면 서버는 초과한 요청을 나중에 처리한다.
- **최대 TPS를 초과하는 요청이 들어올 경우 사용자 입장에서는 응답 시간이 증가하는 문제를 겪게된다.**
- TPS를 높이기 위해 서버가 동시에 처리할 수 있는 요청 수를 늘리거나, 처리 시간 자체를 줄이는 방법을 고려한다.
- TPS를 확인하기 위해 모니터링 시스템을 활용한다. (ex. **스카우터**, **핀포인트**, **뉴렐릭** 등)

## 수직 확장과 수평 확장
- 개선안을 도출하기 전, 급한 불을 꺼야할 때 수직 확장과 수평 확장을 고려할 수 있다.
### 수직 확장
- scale-up
- CPU, 메모리, 디스크 등의 자원을 증가시키는 것
### 수평 확장
- scale-out
- 서버를 늘리는 방식이다
- 서버가 두 대 이상이면 트래픽을 알맞게 분산시켜주는 **로드 밸런서(load balancer)** 가 필요하다.
- 병목 지점을 파악하고 수행해야한다.
  - 성능 문제가 DB에 있는 것인데, DB를 사용하는 서버를 더 늘리면 더 악화될 뿐이다.
  - 마찬가지로 문제 발생 지점이 외부 API인데 이 경우에 우리 서버를 늘려봤자이다.
  
## DB 커넥션 풀
- DB를 사용(쿼리 실행)하기 위해서는 DB와 연결하고 종료하는 과정이 필요하다. 그리고 해당 과정이 소요 시간의 큰 비중을 차지한다.
- 때문에, DB 커넥션 풀에 미리 DB와 연결된 커넥션들을 준비해놓고 그것을 가져다 쓰는 것이다.
### 커넥션 풀 크기
- 트래픽의 패턴에 맞추어 커넥션풀의 최소 크기와 최대 크기를 지정한다.
- DB의 상태를 고려하지 않고 무턱대고 크기를 늘리면 DB에 부하가 가해지고, 쿼리 실행 시간이 급격히 증가할 수 있으므로 주의한다.
### 커넥션 대기 시간
- 풀에 사용할 수 있는 커넥션이 없을 때 커넥션을 얻기 위해 기다릴 수 있는 최대 시간인 대기 시간을 설정할 수 있다.
- 대기 시간이 길면, 응답 시간이 길어지고 일반적으로 이 경우에 유저는 재요청을 한다. 이럴 경우 요청이 쌓여 서버에 부하가 가해진다. 대기 시간을 짧게 가져가고 에러를 반환하는게 오히려 낫다.

## 서버 캐시
- cache, 일종의 (키, 값) 쌍을 저장하는 Map과 같은 형태의 데이터 저장소.
### 적중률과 삭제 규칙
- 적중률 hit rate, 캐시가 얼마나 효율적으로 사용되는지 파악할 수 있는 지표.
- 적중률 = 캐시에 존재한 건수 / 캐시에서 조회를 시도한 건수
- 적중률이 높을수록 DB와의 연동이 줄어들고 곧 응답 시간 감소, 처리량 증가, DB 부하 감소로 이어진다.
- 물론 또한 메모리 자원을 사용하기 때문에 무작정 많은 데이터를 저장할 수는 없다.
- 새 데이터를 저장하기 위해 기존의 데이터를 제거한다.
  - LRU(Least Recently Used): 가장 오래 전에 사용된 데이터를 제거한다.
  - LFU(Least Frequently Used): 가장 적게 사용된 데이터를 제거한다.
  - FIFO(First In First Out): 먼저 추가된 데이터를 먼저 삭제한다.
### 로컬 캐시와 리모트 캐시
- 로컬(local) 캐시
  - 서버 프로세스와 동일한 메모리를 캐시 저장소로 사용한다.
  - 빠르지만 데이터 크기에 제한이 있다.
  - 서버 프로세스를 재시작 할 시에 캐시 데이터가 모두 삭제된다.
- 리모트(remote) 캐시
  - 별도의 메모리를 사용한다.
  - 서버와 네트워크 통신을 해야해서 상대적으로 속도가 느리지만, 수평확장 할 수 있다.
  - 또한, 서버 프로세스를 재시작하더라도 캐시 데이터를 유지할 수 있다.
  - 레디스(Redis)가 이에 해당한다.
### 캐시 사전 적재
- 트래픽이 순간적으로 급증하는 패턴을 보일 때, 미리 캐시 데이터를 저장해 놓을 수 있다.
- 예로, 정기적으로 이달의 요금을 푸시 알림 보내는 경우 알림 발송 후 사용자가 급증해 해당 정보를 조회할 것이므로, 해당 요금 정보를 미리 캐시 데이터로 저장해놓는 것이다.

## 가비지 컬렉터와 메모리 사용
- 가비지 컬렉터(Garbage Collector)
  - 사용이 끝난 객체를 힙 메모리에서 바로 삭제하지 않고 정해진 규칙에 따라 사용하지 않는 메모리를 찾아서 반환한다.
- 자바, Go, 파이썬 등의 언어는 가비지 컬렉터를 사용한다.
- 개발자가 메모리를 직접 관리해야 하는 부담을 줄여주지만, 응답 시간에 영향을 줄 수 있다. 자바의 경우 가비지 컬렉터가 실행되는 동안 애플리케이션의 실행이 일시 중단된다.
- 메모리가 클 경우, GC가 제거해야 할 미사용 객체를 탐색하는 데에 시간이 오래 걸린다. 때문에 힙 메모리 크기를 마냥 키워서는 안된다.
- 한 번에 대량으로 객체를 생성하는 것을 주의해야 한다.
  - 조회 범위를 제한한다.
  - 파일 다운로드와 같은 기능을 구현할 때는 스트림을 활용한다.
 
## 응답 데이터 압축
- 응답 데이터를 압축해 응답 시간을 감소시킬 수 있다.
- 응답 데이터 압축은 시간 뿐 아니라 비용에도 영향을 준다.

## 정적 자원
- 정적 자원은 전체 트래픽에서 상당한 비중을 차지한다.
- 동일한 페이지에 들어갈 때마다 같은 이미지나 JS 파일을 매번 다운로드하면 서버 입장에서 좋을 게 없다.
### 브라우저 캐시
- 클라이언트 캐시를 활용해 같은 url에서의 정적 자원을 반복해서 요청하는 것을 방지한다.
- 예로, 응답 헤더에 `Cache-Control: max-age=60` 를 지정해줄 경우, 같은 주소를 60초 이내에 다시 요청하면 로컬에 보관한 데이터를 사용해 표시하는 것이다.
### CDN
- Content Delivery Network(콘텐츠 전송 네트워크)
- 콘텐츠를 제공하기 위한 별도의 네트워크이다.
- 대표적인 서비스: Amazon CloudFront, Akamai, Cloudflare 등
- 사용자는 CDN이 제공하는 URL을 통해 콘텐츠에 접근한다. CDN 서버에 요청 콘텐츠가 없을 경우 오리진 서버에서 읽어와 제공하고 캐시에 보관한다.

## 대기 처리
- 콘서트 예매와 같이 사용자가 순간적으로 폭증할 경우 대기 처리를 한다.
- 수용할 수 있는 수준의 트래픽만 받아들이고 나머지는 대기하라고 안내하는 것이다.
