# 1부. 스토리지 엔진 
- **데이터베이스 엔진**(database engine) 또는 **스토리지 엔진**(storage engine)은 데이터베이스 관리 시스템(DBMS)이 데이터베이스에 대해 데이터를 삽입, 추출, 업데이트 및 삭제(CRUD)하는 데 사용하는 기본 소프트웨어 컴포넌트이다.
  데이터베이스 엔진을 조작할 때 DBMS 고유의 사용자 인터페이스를 이용하는 방법과 포트 번호를 이용하는 방법이 있다. 대부분의 데이터베이스 관리시스템은 DBMS의 사용자 인터페이스를 통하지 않고, 사용자가 내장된 엔진과 상호작용할 수 있는 자신만의 애플리케이션 프로그래밍 인터페이스(API)를 포함하고 있다.
  (출처: 위키백과)
- 스토리지 엔진은 DMBS에서 데이터를 메모리와 디스크에 저장하고 검색 및 관리하는 소프트웨어 컴포넌트로서 각 노드에 데이터를 영구 저장한다.

<br>

# 1장. 소개 및 개요
## DBMS 구조
- DBMS는 클라이언트/서버 모델을 기반으로 한다. 데이터베이스 인스턴스(노드)와 애플리케이션 인스턴스는 각각 서버와 클라이언트 역할을 한다.
- 클라이언트의 요청은 트랜스포트(transport) 서브시스템을 통해 전달된다. 요청은 쿼리 형태이고 주로 특정 쿼리 언어로 표현한다. 트랜스포트 서브시스템은 데이터베이스 클러스터 노드 사이의 통신에도 사용된다.
- 스토리지 엔진은 다음의 컴포넌트로 구성된다.
  - **트랜잭션 매니저(transaction manager)**: 트랜잭션을 스케줄링하고 데이터베이스 상태의 논리적 일관성을 보장한다.
  - **잠금 매니저(lock manager)**: 트랜잭션에서 접근하는 데이터베이스 객체에 대한 잠금을 제어한다. 동시 수행 작업이 물리적 데이터 무결성을 침해하지 않도록 제어한다.
  - **액세스 메소드(access method)**: 디스크에 저장된 데이터에 대한 접근 및 저장 방식을 정의한다. 힙 파일과 B-트리 또는 LSM 트리 등의 자료 구조를 사용한다.
  - **버퍼 매니저(buffer manager)**: 데이터 페이지를 메모리에 캐시한다.
  - **복구 매니저(recovery manager)**: 로그를 유지 관리하고 장애 발생 시 시스템을 복구한다.
  - 트랜잭션 매니저와 잠금매니저는 동시성 제어. 무결성 보장.

<br>

## 인메모리 DBMS 대 디스크 기반 DBMS
- DBMS는 데이터를 메모리와 디스크에 저장한다.
- 인메모리 DBMS: 데이터 -> 메모리 / 복구와 로그 -> 디스크
- 디스크 기반 DBMS: 데이터 -> 디스크 / 캐시 또는 임시 저장 -> 메모리
- 메모리는 디스크보다 훨씬 더 빠르게 접근할 수 있어 효율성 측면에서 좋으나, 비용적 측면에서 SSD/HDD에 비해 RAM의 가격이 더 높다.

<br>

## 칼럼형 DBMS 대 로우형 DBMS
- 칼럼형 DBMS: 같은 칼럼(column)(ex. 가격)에 해당하는 값들을 저장한다.(수직 분할)
- 로우형 DBMS: 논리적으로 같은 레코드에 속하는 값의 집합인 로우(row)(ex. PK 53번에 해당하는 레코드)에 속하는 값들을 함께 저장한다.(수평 분할)
- MySQL, PostgreSQL 등 대부분의 전통적인 관계형 데이터베이스는 로우형 DBMS다.
- 둘 중 어떤 것을 사용할지 선택하려면 먼저 액세스 패턴을 파악해야한다.
  - 데이터를 레코드 단위(ex. 특정 상품의 모든 정보)로 접근 -> 로우형 DBMS가 적합
  - 여러 로우를 스캔하거나 일부 칼럼에 대한 집계 작업(ex. 시세 파악)이 많을 경우 -> 칼럼형 DBMS가 적합
 
<br>

## 데이터 파일과 인덱스 파일
- 데이터베이스 시스템은 데이터를 파일에 저장한다. 일반적인 파일시스템 대신 구현 방식에 맞는 특수한 포맷을 사용한다.
  - **저장 효율성**: 데이터 레코드의 저장 오버헤드를 최소화하는 방식으로 파일을 구성할 수 있다.
  - **접근 효율성**: 최소한의 단계로 원하는 레코드를 찾을 수 있다.
  - **갱신 효율성**: 디스크 쓰기를 최소화하는 방식으로 레코드를 갱신할 수 있다.
- **인덱스**: 전체 필드 중 레코드를 식별할 수 있는 필드들의 부분집합을 사용해 구축된다.
- 데이터베이스 시스템은 **데이터 파일**과 **인덱스 파일**을 분리한다.
  - 데이터 파일: 데이터 레코드 저장
  - 인덱스 파일: 레코드에 대한 메타데이터를 저장, 이를 사용해 데이터 파일에서의 레코드 위치를 찾는다.
 
### - 데이터 파일
- **인덱스 구조형 테이블(IOT, Index-Organized Table)**
  - 인덱스에 실제 데이터 레코드를 저장한다.
  - 데이터는 키 순서로 정렬되기 때문에 IOT의 범위 스캔은 실제 값을 순서대로 읽으면서 비교한다.
  - 디스크 탐색 횟수를 최소 1회 줄일 수 있다.
- **힙 구조형 테이블(Heap-Organized Table)**
  - 레코드를 특정 순서를 따르지 않고 대체로 삽입 순서대로 저장한다.
  - 새로운 페이지가 추가돼도 파일 재구성 x
  - 데이터 검색 시 데이터의 실제 위치를 가리키는 인덱스가 필요
- **해시 구조형 테이블(Hash-Organized Table)**
  - 레코드를 각 키의 해시 값에 해당하는 버킷에 저장한다.
  - 버킷 내 레코드는 삽입 순서대로 저장하거나 키 순서로 졍렬하면 조회 속도를 향상시킬 수 있다.

### - 인덱스 파일
- 인덱스 파일은 (힙 파일의 경우) **데이터 레코드를 식별할 수 있는 키** 또는 (IOT의 경우) **기본 키**를 데이터 파일에서 해당 레코드의 위치에 매핑한다.
- **기본(primary) 인덱스**
  - 일반적으로 기본 키(primary key)
  - 키별로 하나의 레코드만 가리킨다(1:1)
- **보조(secondary) 인덱스**
  - 그 외 인덱스
  - 데이터 레코드를 직접 가리키거나 해당 레코드의 기본키를 저장한다.
  - 키별로 여러 레코드를 가리킬 수도 있다.(1:N)
- **클러스터형(clustered) 인덱스**
  - 실제 데이터 레코드의 정렬 순서와 검색 키의 정렬 순서가 같은 인덱스
  - 레코드는 보통 같은 인덱스 파일 또는 클러스터형 파일에 정렬해 저장한다. (= '데이터파일/인덱스파일 분리 안돼있다'? = 'IOT'?)
  - 기본 인덱스는 대부분 클러스터형 인덱스
- **비클러스터형(unclustered or non-clustered) 인덱스**
  - 데이터 레코드가 인덱스 키를 기준으로 정렬되지 않았다.
  - 데이터가 다른 파일에 저장돼 있다.
  - 보조 인덱스는 비클러스터형 인덱스
 
<br>

## 버퍼링과 불변성, 순서화
- 데이터베이스 자료 구조에는 세 가지 공통점이 있다.
  - 버퍼링을 사용한다(또는 사용하지 않는다)
  - 불변 파일(또는 가변 파일)을 사용한다
  - 저장할 때 값의 순서를 유지한다(또는 유지하지 않는다)
  - ???
 
<br>

# 2장. B-트리 개요
## 이진 탐색 트리
- 이진 탐색 트리(BST, Binary Search Tree)는 정렬된 인메모리 자료 구조로, 키-값 쌍 검색에 사용된다.
- 키와 두 개(이진)의 자식 포인터가 저장된 여러 노드로 구성된다.
- 탐색은 루트 노드에서 시작한다.
- 각 노드의 키는 왼쪽 서브트리의 모든 노드 키보다 크고 오른쪽 서브트리의 모든 키보다 작다. (K<sub>left</sub> < K < K<sub>right</sub>)

### - 트리 밸런싱
- 노드 삽입 작업에 특정 패턴이 없으며, 삽입하는 값에 따라 트리가 불균형해질 수 있다.
- ex. 오름차순 정렬된 순서대로 삽입 될 경우
- <img width="300" height="300" alt="불균형 트리" src="https://github.com/user-attachments/assets/8f05d7e7-e45a-4099-a77c-b55e4cb738da" />
- 위 예시의 경우 선형 복잡도의 링크드 리스트 형태이다. (시간 복잡도 O(N), 균형 트리의 평균 시간 복잡도는 O(log<sub>2</sub>N))
- 트리의 균형을 유지하기 위해 트리를 재구성한다.(트리 높이 최소화) -> 유지 비용으로 이어짐

### - 디스크 기반 스토리지용 트리
- 디스크 저장에 적합한 트리에는 다음 두 가지 특성이 있다.
  - 인접한 키의 지역성을 높이기 위한 높은 팬아웃(fanout)
  - 트리 순회 중 디스크 탐색 횟수를 줄이기 위한 낮은 트리 높이 
- BST는 트리의 팬아웃이 낮기 때문에(2) 트리 밸런싱과 노드 재배치, 포인터 갱신이 자주 발생해 유지 비용이 높아 디스크 기반 자료 구조로는 적합하지 않다.

<br>

## 디스크 기반 자료 구조
### - 하드 디스크 드라이브
- 디스크에서는 탐색 작업이 랜덤 읽기 비용의 많은 부분을 차지한다. 디스크를 회전하고 읽기/쓰기용 헤드를 원하는 위치까지 **물리적으로** 옮겨야 하기 때문이다.
- 하지만 이 과정 이후의 **연속된 바이트 읽기/쓰기(순차적 작업)** 는 상대적으로 비용이 낮다.
- HDD 작업 중 **물리적 헤드 이동**이 비용이 가장 높다. 따라서 디스크에서 연속된 메모리 섹터를 일고 쓰는 순차적 I/O를 극대화해야 한다.

### - 솔리드 스테이트 드라이브
- SSD(Solid State Drive)는 물리적으로 움직이는 부품이 없다.
- SSD는 다음과 같이 구성된다. **메모리 셀(cell) -> 스트링 -> 페이지 -> 블록**
- 셀은 한 개 또는 여러 개의 **비트**를 저장한다.
- 블록의 집합은 플레인(plane), 플레인의 집합은 다이(die)라고 부르며 SSD는 한 개 이상의 다이로 구성된다.
- <img width="481" height="341" alt="SSD 계층" src="https://github.com/user-attachments/assets/9233a5d5-e6ab-41ff-8bf6-96e5d2e1c50c" />
- **읽고 쓸 수 있는 가장 작은 단위: 페이지**
- **삭제할 수 있는 가장 작은 단위: 블록**
- HDD와 SSD는 개별 바이트 단위가 아닌 메모리 청크 단위로 데이터를 참조한다. 따라서 대부분의 운영체제에는 블록 디바이스 추상화 계층이 있다. 이 계층은 하드 디스크의 내부 구조를 추상화하고 I/O 작업을 내부적으로 버퍼링한다.
- SSD는 HDD와 다르게 랜덤과 순차 I/O의 구분이 중요하지 않다.

<br>

## B-트리 계층
- B-트리는 여러 노드로 구성된다. 각 노드는 최대 N개의 키와 N+1개의 자식 노드 포인터를 저장한다.
- 노드는 세 개의 계층으로 나눌 수 있다.
  - 루트 노드: 트리의 최상위 노드. 부모 노드 없음.
  - 내부 노드: 루트와 리프를 연결하는 모든 노드.
  - 리프 노드: 트리의 최하위 노드. 자식 노드 없음.
- B-트리는 **페이지 기반 자료 구조**이기 때문에 노드와 페이지가 같은 의미로 쓰이기도 한다.

### - 구분 키
- B-트리 노드에 저장된 키를 인덱스 엔트리, 구분 키, 또는 디바이더 셀(divider cell)이라고 부른다.
- 각 키는 트리를 해당 키 범위의 서브트리로 분할한다.
- <img width="461" height="161" alt="구분 키가 트리를 서브트리로 나누는 방식" src="https://github.com/user-attachments/assets/c890cf21-ecb5-4894-8125-dcc59d8c8912" />
- 일부 변형 B-트리에서는 리프 노드에 형제 노드를 가리키는 포인터를 저장한다. 그러면 부모를 거치지 않고 형제 노드에 바로 접근할 수 있다.
- B-트리는 나중에 삽입 및 업데이트될 노드의 공간을 미리 확보해둔다.

### - B-트리 탐색 알고리즘
- B-트리에서 특정 값을 찾으려면 루트에서 리프 레벨까지 순회해야 한다. 탐색의 목적은 특정 키 또는 바로 앞 키를 찾는 것이다.
  - 포인트 쿼리와 업데이트, 삭제 작업 시에는 정확히 일치하는 키를 찾아야 한다.
  - 범위 스캔과 새로운 노드 삽입 시에는 대상 키의 바로 앞의 값을 찾아야 한다.
- 탐색 알고리즘은 루트 노드에서부터 이진 검색을 수행한다.
  - 포인트 쿼리는 특정 키를 찾거나 찾는 데 실패했을 때 완료된다.
  - 범위 스캔은 첫 번째 키-값 쌍에서 시작해 범위의 끝에 도달하거나 더 이상 조건을 충족하지 않는 노드를 찾을 대까지 형제 노드 포인터를 따라간다.
 
### - B-트리 노드 분할
- B-트리에 새로운 노드를 삽입하려할 때, 리프 노드에 남은 공간이 없는 노드를 오버플로우(overflow)상태라고 표현한다.
- 오버플로우 상태의 노드는 분할한다. 노드 분할 작업의 조건은 다음과 같다.
  - 리프 노드: 노드에 최대 N개의 키-값 쌍을 저장할 수 있고 새로운 키-값 쌍 삽입 시 용량이 초과되는 경우
  - 리프x 노드: 노드에 최대 N+1개의 포인터를 저장할 수 있고 포인터 추가 시 용량이 초과되는 경우
- 노드 분할 단계
  - a. 새로운 노드를 할당한다.
  - b. 분할 노드 키의 절반을 새로운 노드로 복사한다.
  - c. 새로운 키를 알맞은 노드에 삽입한다.
  - d. 분할 노드의 부모 노드에 분할 키와 새로운 노드를 카리키는 포인터를 추가한다. (=> 키의 승급)

<br>


# 3장. 파일 포맷

- **메모리 접근 방식**, 가상 메모리를 사용하면 오프셋을 직접 관리하지 않아도 된다.
- **디스크 접근 방식**, 시스템 호출을 통해 접근이 이뤄진다. 대상 파일 내의 오프셋을 직접 지정해야 하며, 디스크상의 표현을 메인 메모리에서 읽을 수 있는 형태로 변환해야 한다.

- 디스크 기반 B-트리는 페이지 단위로 구성 및 탐색하기 때문에 일종의 페이지 관리 메커니즘이라고 볼 수 있다. 페이지와 페이지를 가리키는 포인터를 계산해 알맞게 배치해야 한다.

## 파일 포맷의 중요성
- 파일 포맷 설계
  - 데이터 블록을 할당하고 고정 크기의 기본형과 자료 구조를 사용해 원하는 모양대로 블록을 잘라서 사용한다.
  - 큰 메모리 청크(chunk) 또는 가변 길이의 자료 구조는 포인터를 사용해 참조한다.
 
<br>

## 바이너리 인코딩
- 데이터를 효율적으로 디스크에 저장하려면, 컴팩트하고 직렬화와 역직렬화가 쉬운 포맷으로 인코딩해야 한다.

### - 기본형
- 키와 값은 integer, date, string 등의 지정된 자료형이 있고 바이너리 형식(직렬화의 결과 형식이자 역직렬화의 입력 형식)으로 표현할 수 있다.
- 레코드는 숫자, 문자열, 불리언과 같은 기본형과 이들의 조합으로 구성된다. **바이트 시퀀스 형태**로 네트워크를 통해 전송되고 디스크에 저장한다. (serialize <-> deserialize)

- 대부분의 숫자형은 고정 길이 자료형이다.
  - byte형은 8비트
  - short는 2바이트(=16비트)
  - int는 4바이트(=32비트)
  - long은 8바이트(=64비트)
- 부동소수점(float과 double)은 부호(sign)와 가수(fraction), 지수(exponent)로 구성된다.
  - 가수를 사용하기 때문에 결괏값은 근삿값이다.
  - float는 32비트로 단정도(단정밀도, single precison), double은 64비트로 배정도(배정밀도, double precision)이다. double의 비트수가 두배로, 값의 정밀도가 두배이다.
  - 구성은 다음과 같다.
    - <img width="923" height="287" alt="image" src="https://github.com/user-attachments/assets/cfe8dd66-48c1-4c13-a9e7-17403834984f" />
  - 여기서 변환이 중요한 것은 아니지만 간단히 다음과 같다.
    - 숫자를 이진수로 표현한다.
    - 해당 이진수를 정규화 한다. (=소숫점 왼쪽에 한 자리만 존재하도록 한다. x.xxx * 2*n 과 같은 형태가 된다(x는 0 또는 1).)
    - 위 정규화 된 값에서 소수점 오른쪽에 있는 숫자가 가수에 해당하며 n이 지수이다.
    - 지수(n) 또한 이진수로 변환하여 지수부를 구성한다.

### - 문자열과 가변 길이 데이터
- 문자열과 가변 길이 자료형은 배열의 크기 또는 문자열의 길이를 나타내는 숫자와 size 바이트 크기의 실제 데이터로 구성된다.

### - 비트 묶음형 데이터: 불리언, 열거형, 플래그
- 불리언 자료형은 단일 바이트 또는 true와 false를 1과 0으로 인코딩한 값을 표현한다. 두 개의 값만 표현할 수 있기 때문에 바이트 전체를 사용하는 것은 낭비다. 따라서 8개의 불리언 값이 각 1비트씩 사용하도록 묶어 쓰기도 한다(묶음형(packed) 불리언).
- Enum은 열거형(enumerated type)의 줄임말이며 숫자를 표현한다.
- 플래그(flag)는 묶음형 불리언과 열거형의 조합이다.

<br>

## 파일 포맷 설계 원칙
- 일반적으로 파일은 고정크기의 헤더(header)로 시작하며 끝부분에 고정 크기의 트레일러(trailer)가 있다. 여기에는 빠르게 접근해야 하거나 파일의 나머지 부분을 디코딩하는 데 필요한 보조 정보가 들어간다. 파일의 나머지 부분은 페이지로 나눠 저장한다.
- 데이터베이스 파일은 일반적으로, 탐색에 유용한 룩업 테이블(lookup table)을 유지하고 각 레코드의 시작점을 가리키는 오프셋은 헤더와 트레일러 또는 개별 파일에 저장한다.

<br>

## 페이지 구조
- 데이터베이서 시스템은 데이터 레코드를 데이터 파일과 인덱스 파일에 저장한다.
- 파일은 여러 파일시스템 블록을 합친 고정 크기의 페이지로 구성된다.

<br>

## 슬롯 페이지
- 페이지 포맷은 다음 조건을 충족해야 한다.
  - 최소한의 오버헤드로 가변 길이 레코드 저장 (오버헤더: 컴퓨터 시스템에서 모든 사용자 또는 프로세스에 이점을 제공하지만 특정 작업에 직접적으로 기인할 수 없는 공유 기능, 헤더 및 테일 같은 것.)
  - 삭제된 레코드의 메모리 회수
  - 페이지의 레코드를 정확한 위치와 상관없이 참조
- 슬롯 페이지(slotted page) 또는 슬롯 디렉터리(slot directory)를 사용하면 문자열, 블랍(BLOB, binary large object)과 같은 가변 길이 자료형을 효율적으로 저장할 수 있다(위 조건을 충족한다). PostgreSQL이 이 방식을 사용한다.
- 페이지는 슬롯 또는 셀의 집합이다.
  - 페이지 내 **독립적인 영역**에 포인터와 셀을 분리해서 저장한다.
  - 레코드의 논리적 순서는 **셀을 가리키는 포인터의 순서**로 제어한다.
  - 레코드 삭제 시 해당 포인터를 삭제하거나 null로 설정한다.
- 슬롯 페이지에는 페이지와 셀에 대한 중요한 정보를 저장하는 고정 길이의 헤더가 있다. (관리 영역)
- 셀에는 키와 포인터, 레코드 등 임의의 데이터를 저장할 수 있으며 셀마다 크기는 다를 수 있다.

<br>

## 셀 구조
- 셀을 병합하면 페이지가 되고 페이지를 병합하면 트리가 된다.
- 셀은 키 셀과 키-값 셀로 나눌 수 있다.
- 키 셀의 구성 요소
  - 셀 종류(페이지 메타데이터로부터 알아낼 수 있음)
  - 키 길이
  - 셀이 가리키는 자식 페이지의 ID
  - 키 바이트
- 키-값 셀의 구성 요소
  - 셀 종류(페이지 메타데이터로부터 알아낼 수 있음)
  - 키 길이
  - 값 길이
  - 키 바이트
  - 데이터 레코드 바이트
 
<br>

## 셀 병합으로 슬롯 페이지 구성
- 페이지의 셀은 오른쪽에 추가하고 셀 오프셋/포인터는 왼쪽에 추가한다.  (페이지의 가운데가 비어있는 구조)
  - <img width="605" height="210" alt="image" src="https://github.com/user-attachments/assets/c513f999-0f7c-49f4-9fad-80b90e27f900" />
- 셀은 삽입 순서대로 배치되고(오른쪽 끝 -> 왼쪽 앞 방향으로 순서대로 채워짐) 오프셋은 이진 탐색이 가능하도록 정렬한다(페이지의 왼쪽 파트를 구성하는 오프셋들은 논리적 순서에 맞춰 재정렬 됨).

<br>

## 가변 길이 데이터 관리
- 페이지 레코드 삭제 시 실제로 셀을 지우고 할당 해제된 공간으로 다른 셀을 옮길 필요는 없다. (페이지의 오른쪽 파트는 데이터가 듬성듬성)
- 대신 삭제된 셀이라고 표시하고 메모리에 저장된 사용 가능 목록(availability list)에 회수된 메모리 크기와 해당 위치를 가리키는 포인터를 업데이트 한다.
- 새로운 셀을 삽입하기 전에 위 목록을 먼저 체크한다.


