# 1부. 스토리지 엔진 
- **데이터베이스 엔진**(database engine) 또는 **스토리지 엔진**(storage engine)은 데이터베이스 관리 시스템(DBMS)이 데이터베이스에 대해 데이터를 삽입, 추출, 업데이트 및 삭제(CRUD)하는 데 사용하는 기본 소프트웨어 컴포넌트이다.
  데이터베이스 엔진을 조작할 때 DBMS 고유의 사용자 인터페이스를 이용하는 방법과 포트 번호를 이용하는 방법이 있다. 대부분의 데이터베이스 관리시스템은 DBMS의 사용자 인터페이스를 통하지 않고, 사용자가 내장된 엔진과 상호작용할 수 있는 자신만의 애플리케이션 프로그래밍 인터페이스(API)를 포함하고 있다.
  (출처: 위키백과)
- 스토리지 엔진은 DMBS에서 데이터를 메모리와 디스크에 저장하고 검색 및 관리하는 소프트웨어 컴포넌트로서 각 노드에 데이터를 영구 저장한다.

<br>

# 1장. 소개 및 개요
## DBMS 구조
- DBMS는 클라이언트/서버 모델을 기반으로 한다. 데이터베이스 인스턴스(노드)와 애플리케이션 인스턴스는 각각 서버와 클라이언트 역할을 한다.
- 클라이언트의 요청은 트랜스포트(transport) 서브시스템을 통해 전달된다. 요청은 쿼리 형태이고 주로 특정 쿼리 언어로 표현한다. 트랜스포트 서브시스템은 데이터베이스 클러스터 노드 사이의 통신에도 사용된다.
- 스토리지 엔진은 다음의 컴포넌트로 구성된다.
  - **트랜잭션 매니저(transaction manager)**: 트랜잭션을 스케줄링하고 데이터베이스 상태의 논리적 일관성을 보장한다.
  - **잠금 매니저(lock manager)**: 트랜잭션에서 접근하는 데이터베이스 객체에 대한 잠금을 제어한다. 동시 수행 작업이 물리적 데이터 무결성을 침해하지 않도록 제어한다.
  - **액세스 메소드(access method)**: 디스크에 저장된 데이터에 대한 접근 및 저장 방식을 정의한다. 힙 파일과 B-트리 또는 LSM 트리 등의 자료 구조를 사용한다.
  - **버퍼 매니저(buffer manager)**: 데이터 페이지를 메모리에 캐시한다.
  - **복구 매니저(recovery manager)**: 로그를 유지 관리하고 장애 발생 시 시스템을 복구한다.
  - 트랜잭션 매니저와 잠금매니저는 동시성 제어. 무결성 보장.

<br>

## 인메모리 DBMS 대 디스크 기반 DBMS
- DBMS는 데이터를 메모리와 디스크에 저장한다.
- 인메모리 DBMS: 데이터 -> 메모리 / 복구와 로그 -> 디스크
- 디스크 기반 DBMS: 데이터 -> 디스크 / 캐시 또는 임시 저장 -> 메모리
- 메모리는 디스크보다 훨씬 더 빠르게 접근할 수 있어 효율성 측면에서 좋으나, 비용적 측면에서 SSD/HDD에 비해 RAM의 가격이 더 높다.

<br>

## 칼럼형 DBMS 대 로우형 DBMS
- 칼럼형 DBMS: 같은 칼럼(column)(ex. 가격)에 해당하는 값들을 저장한다.(수직 분할)
- 로우형 DBMS: 논리적으로 같은 레코드에 속하는 값의 집합인 로우(row)(ex. PK 53번에 해당하는 레코드)에 속하는 값들을 함께 저장한다.(수평 분할)
- MySQL, PostgreSQL 등 대부분의 전통적인 관계형 데이터베이스는 로우형 DBMS다.
- 둘 중 어떤 것을 사용할지 선택하려면 먼저 액세스 패턴을 파악해야한다.
  - 데이터를 레코드 단위(ex. 특정 상품의 모든 정보)로 접근 -> 로우형 DBMS가 적합
  - 여러 로우를 스캔하거나 일부 칼럼에 대한 집계 작업(ex. 시세 파악)이 많을 경우 -> 칼럼형 DBMS가 적합
 
<br>

## 데이터 파일과 인덱스 파일
- 데이터베이스 시스템은 데이터를 파일에 저장한다. 일반적인 파일시스템 대신 구현 방식에 맞는 특수한 포맷을 사용한다.
  - **저장 효율성**: 데이터 레코드의 저장 오버헤드를 최소화하는 방식으로 파일을 구성할 수 있다.
  - **접근 효율성**: 최소한의 단계로 원하는 레코드를 찾을 수 있다.
  - **갱신 효율성**: 디스크 쓰기를 최소화하는 방식으로 레코드를 갱신할 수 있다.
- **인덱스**: 전체 필드 중 레코드를 식별할 수 있는 필드들의 부분집합을 사용해 구축된다.
- 데이터베이스 시스템은 **데이터 파일**과 **인덱스 파일**을 분리한다.
  - 데이터 파일: 데이터 레코드 저장
  - 인덱스 파일: 레코드에 대한 메타데이터를 저장, 이를 사용해 데이터 파일에서의 레코드 위치를 찾는다.
 
### - 데이터 파일
- **인덱스 구조형 테이블(IOT, Index-Organized Table)**
  - 인덱스에 실제 데이터 레코드를 저장한다.
  - 데이터는 키 순서로 정렬되기 때문에 IOT의 범위 스캔은 실제 값을 순서대로 읽으면서 비교한다.
  - 디스크 탐색 횟수를 최소 1회 줄일 수 있다.
- **힙 구조형 테이블(Heap-Organized Table)**
  - 레코드를 특정 순서를 따르지 않고 대체로 삽입 순서대로 저장한다.
  - 새로운 페이지가 추가돼도 파일 재구성 x
  - 데이터 검색 시 데이터의 실제 위치를 가리키는 인덱스가 필요
- **해시 구조형 테이블(Hash-Organized Table)**
  - 레코드를 각 키의 해시 값에 해당하는 버킷에 저장한다.
  - 버킷 내 레코드는 삽입 순서대로 저장하거나 키 순서로 졍렬하면 조회 속도를 향상시킬 수 있다.

### - 인덱스 파일
- 인덱스 파일은 (힙 파일의 경우) **데이터 레코드를 식별할 수 있는 키** 또는 (IOT의 경우) **기본 키**를 데이터 파일에서 해당 레코드의 위치에 매핑한다.
- **기본(primary) 인덱스**
  - 일반적으로 기본 키(primary key)
  - 키별로 하나의 레코드만 가리킨다(1:1)
- **보조(secondary) 인덱스**
  - 그 외 인덱스
  - 데이터 레코드를 직접 가리키거나 해당 레코드의 기본키를 저장한다.
  - 키별로 여러 레코드를 가리킬 수도 있다.(1:N)
- **클러스터형(clustered) 인덱스**
  - 실제 데이터 레코드의 정렬 순서와 검색 키의 정렬 순서가 같은 인덱스
  - 레코드는 보통 같은 인덱스 파일 또는 클러스터형 파일에 정렬해 저장한다. (= '데이터파일/인덱스파일 분리 안돼있다'? = 'IOT'?)
  - 기본 인덱스는 대부분 클러스터형 인덱스
- **비클러스터형(unclustered or non-clustered) 인덱스**
  - 데이터 레코드가 인덱스 키를 기준으로 정렬되지 않았다.
  - 데이터가 다른 파일에 저장돼 있다.
  - 보조 인덱스는 비클러스터형 인덱스
 
<br>

## 버퍼링과 불변성, 순서화
- 데이터베이스 자료 구조에는 세 가지 공통점이 있다.
  - 버퍼링을 사용한다(또는 사용하지 않는다)
  - 불변 파일(또는 가변 파일)을 사용한다
  - 저장할 때 값의 순서를 유지한다(또는 유지하지 않는다)
  - ???
 
<br>
