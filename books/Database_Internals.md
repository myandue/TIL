# 1부. 스토리지 엔진 
- **데이터베이스 엔진**(database engine) 또는 **스토리지 엔진**(storage engine)은 데이터베이스 관리 시스템(DBMS)이 데이터베이스에 대해 데이터를 삽입, 추출, 업데이트 및 삭제(CRUD)하는 데 사용하는 기본 소프트웨어 컴포넌트이다.
  데이터베이스 엔진을 조작할 때 DBMS 고유의 사용자 인터페이스를 이용하는 방법과 포트 번호를 이용하는 방법이 있다. 대부분의 데이터베이스 관리시스템은 DBMS의 사용자 인터페이스를 통하지 않고, 사용자가 내장된 엔진과 상호작용할 수 있는 자신만의 애플리케이션 프로그래밍 인터페이스(API)를 포함하고 있다.
  (출처: 위키백과)
- 스토리지 엔진은 DMBS에서 데이터를 메모리와 디스크에 저장하고 검색 및 관리하는 소프트웨어 컴포넌트로서 각 노드에 데이터를 영구 저장한다.

<br>

# 1장. 소개 및 개요
## DBMS 구조
- DBMS는 클라이언트/서버 모델을 기반으로 한다. 데이터베이스 인스턴스(노드)와 애플리케이션 인스턴스는 각각 서버와 클라이언트 역할을 한다.
- 클라이언트의 요청은 트랜스포트(transport) 서브시스템을 통해 전달된다. 요청은 쿼리 형태이고 주로 특정 쿼리 언어로 표현한다. 트랜스포트 서브시스템은 데이터베이스 클러스터 노드 사이의 통신에도 사용된다.
- 스토리지 엔진은 다음의 컴포넌트로 구성된다.
  - **트랜잭션 매니저(transaction manager)**: 트랜잭션을 스케줄링하고 데이터베이스 상태의 논리적 일관성을 보장한다.
  - **잠금 매니저(lock manager)**: 트랜잭션에서 접근하는 데이터베이스 객체에 대한 잠금을 제어한다. 동시 수행 작업이 물리적 데이터 무결성을 침해하지 않도록 제어한다.
  - **액세스 메소드(access method)**: 디스크에 저장된 데이터에 대한 접근 및 저장 방식을 정의한다. 힙 파일과 B-트리 또는 LSM 트리 등의 자료 구조를 사용한다.
  - **버퍼 매니저(buffer manager)**: 데이터 페이지를 메모리에 캐시한다.
  - **복구 매니저(recovery manager)**: 로그를 유지 관리하고 장애 발생 시 시스템을 복구한다.
  - 트랜잭션 매니저와 잠금매니저는 동시성 제어. 무결성 보장.

<br>

## 인메모리 DBMS 대 디스크 기반 DBMS
- DBMS는 데이터를 메모리와 디스크에 저장한다.
- 인메모리 DBMS: 데이터 -> 메모리 / 복구와 로그 -> 디스크
- 디스크 기반 DBMS: 데이터 -> 디스크 / 캐시 또는 임시 저장 -> 메모리
- 메모리는 디스크보다 훨씬 더 빠르게 접근할 수 있어 효율성 측면에서 좋으나, 비용적 측면에서 SSD/HDD에 비해 RAM의 가격이 더 높다.

<br>

## 칼럼형 DBMS 대 로우형 DBMS
- 칼럼형 DBMS: 같은 칼럼(column)(ex. 가격)에 해당하는 값들을 저장한다.(수직 분할)
- 로우형 DBMS: 논리적으로 같은 레코드에 속하는 값의 집합인 로우(row)(ex. PK 53번에 해당하는 레코드)에 속하는 값들을 함께 저장한다.(수평 분할)
- MySQL, PostgreSQL 등 대부분의 전통적인 관계형 데이터베이스는 로우형 DBMS다.
- 둘 중 어떤 것을 사용할지 선택하려면 먼저 액세스 패턴을 파악해야한다.
  - 데이터를 레코드 단위(ex. 특정 상품의 모든 정보)로 접근 -> 로우형 DBMS가 적합
  - 여러 로우를 스캔하거나 일부 칼럼에 대한 집계 작업(ex. 시세 파악)이 많을 경우 -> 칼럼형 DBMS가 적합
 
<br>

## 데이터 파일과 인덱스 파일
- 데이터베이스 시스템은 데이터를 파일에 저장한다. 일반적인 파일시스템 대신 구현 방식에 맞는 특수한 포맷을 사용한다.
  - **저장 효율성**: 데이터 레코드의 저장 오버헤드를 최소화하는 방식으로 파일을 구성할 수 있다.
  - **접근 효율성**: 최소한의 단계로 원하는 레코드를 찾을 수 있다.
  - **갱신 효율성**: 디스크 쓰기를 최소화하는 방식으로 레코드를 갱신할 수 있다.
- **인덱스**: 전체 필드 중 레코드를 식별할 수 있는 필드들의 부분집합을 사용해 구축된다.
- 데이터베이스 시스템은 **데이터 파일**과 **인덱스 파일**을 분리한다.
  - 데이터 파일: 데이터 레코드 저장
  - 인덱스 파일: 레코드에 대한 메타데이터를 저장, 이를 사용해 데이터 파일에서의 레코드 위치를 찾는다.
 
### - 데이터 파일
- **인덱스 구조형 테이블(IOT, Index-Organized Table)**
  - 인덱스에 실제 데이터 레코드를 저장한다.
  - 데이터는 키 순서로 정렬되기 때문에 IOT의 범위 스캔은 실제 값을 순서대로 읽으면서 비교한다.
  - 디스크 탐색 횟수를 최소 1회 줄일 수 있다.
- **힙 구조형 테이블(Heap-Organized Table)**
  - 레코드를 특정 순서를 따르지 않고 대체로 삽입 순서대로 저장한다.
  - 새로운 페이지가 추가돼도 파일 재구성 x
  - 데이터 검색 시 데이터의 실제 위치를 가리키는 인덱스가 필요
- **해시 구조형 테이블(Hash-Organized Table)**
  - 레코드를 각 키의 해시 값에 해당하는 버킷에 저장한다.
  - 버킷 내 레코드는 삽입 순서대로 저장하거나 키 순서로 졍렬하면 조회 속도를 향상시킬 수 있다.

### - 인덱스 파일
- 인덱스 파일은 (힙 파일의 경우) **데이터 레코드를 식별할 수 있는 키** 또는 (IOT의 경우) **기본 키**를 데이터 파일에서 해당 레코드의 위치에 매핑한다.
- **기본(primary) 인덱스**
  - 일반적으로 기본 키(primary key)
  - 키별로 하나의 레코드만 가리킨다(1:1)
- **보조(secondary) 인덱스**
  - 그 외 인덱스
  - 데이터 레코드를 직접 가리키거나 해당 레코드의 기본키를 저장한다.
  - 키별로 여러 레코드를 가리킬 수도 있다.(1:N)
- **클러스터형(clustered) 인덱스**
  - 실제 데이터 레코드의 정렬 순서와 검색 키의 정렬 순서가 같은 인덱스
  - 레코드는 보통 같은 인덱스 파일 또는 클러스터형 파일에 정렬해 저장한다. (= '데이터파일/인덱스파일 분리 안돼있다'? = 'IOT'?)
  - 기본 인덱스는 대부분 클러스터형 인덱스
- **비클러스터형(unclustered or non-clustered) 인덱스**
  - 데이터 레코드가 인덱스 키를 기준으로 정렬되지 않았다.
  - 데이터가 다른 파일에 저장돼 있다.
  - 보조 인덱스는 비클러스터형 인덱스
 
<br>

## 버퍼링과 불변성, 순서화
- 데이터베이스 자료 구조에는 세 가지 공통점이 있다.
  - 버퍼링을 사용한다(또는 사용하지 않는다)
  - 불변 파일(또는 가변 파일)을 사용한다
  - 저장할 때 값의 순서를 유지한다(또는 유지하지 않는다)
  - ???
 
<br>

# 2장. B-트리 개요
## 이진 탐색 트리
- 이진 탐색 트리(BST, Binary Search Tree)는 정렬된 인메모리 자료 구조로, 키-값 쌍 검색에 사용된다.
- 키와 두 개(이진)의 자식 포인터가 저장된 여러 노드로 구성된다.
- 탐색은 루트 노드에서 시작한다.
- 각 노드의 키는 왼쪽 서브트리의 모든 노드 키보다 크고 오른쪽 서브트리의 모든 키보다 작다. (K<sub>left</sub> < K < K<sub>right</sub>)

### - 트리 밸런싱
- 노드 삽입 작업에 특정 패턴이 없으며, 삽입하는 값에 따라 트리가 불균형해질 수 있다.
- ex. 오름차순 정렬된 순서대로 삽입 될 경우
- <img width="300" height="300" alt="제목 없는 다이어그램 drawio" src="https://github.com/user-attachments/assets/8f05d7e7-e45a-4099-a77c-b55e4cb738da" />
- 위 예시의 경우 선형 복잡도의 링크드 리스트 형태이다. (시간 복잡도 O(N), 균형 트리의 평균 시간 복잡도는 O(log<sub>2</sub>N))
- 트리의 균형을 유지하기 위해 트리를 재구성한다.(트리 높이 최소화) -> 유지 비용으로 이어짐

### - 디스크 기반 스토리지용 트리
- 디스크 저장에 적합한 트리에는 다음 두 가지 특성이 있다.
  - 인접한 키의 지역성을 높이기 위한 높은 팬아웃(fanout)
  - 트리 순회 중 디스크 탐색 횟수를 줄이기 위한 낮은 트리 높이 
- BST는 트리의 팬아웃이 낮기 때문에(2) 트리 밸런싱과 노드 재배치, 포인터 갱신이 자주 발생해 유지 비용이 높아 디스크 기반 자료 구조로는 적합하지 않다.
